{"version":3,"sources":["../src/index.ts","../src/utils/asyncCallWithTimeout.ts","../src/utils/BytesHelper.ts","../src/CreateCredentialUtils.ts","../src/utils/BrowserHelper.ts","../src/GetCredentialUtils.ts"],"sourcesContent":["export * from './types/CredentialTypes';\nexport * from './CreateCredentialUtils';\nexport * from './GetCredentialUtils';\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Call an async function with a maximum time limit (in milliseconds) for the timeout\n * @param {Promise<any>} asyncPromise An asynchronous promise to resolve\n * @param {number} timeLimit Time limit to attempt function in milliseconds\n * @return {Promise<any>} Resolved promise for async function call\n */\nexport const asyncCallWithTimeout = async (\n    asyncPromise: Promise<any>,\n    timeLimit: number\n): Promise<any> => {\n    let timeoutHandle: any;\n\n    const timeoutPromise = new Promise((resolve) => {\n        timeoutHandle = setTimeout(resolve, timeLimit);\n    });\n\n    return Promise.race([asyncPromise, timeoutPromise]).then((result) => {\n        clearTimeout(timeoutHandle);\n        return result;\n    });\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n","/**\n * BytesHelper assists in encoding and decoding bytes\n */\nexport default class BytesHelper {\n    /**\n     * Encode bytes using array buffer\n     * @param {ArrayBufferLike} arrayBuffer The array buffer\n     * @return {string} Base64 URL string\n     */\n    public static encodeBytes(arrayBuffer: ArrayBufferLike): string {\n        const b64Str = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n        const b64URLStr = b64Str.replace(/\\+/g, '-').replace(/\\//g, '_');\n        return removePadding(b64URLStr);\n    }\n\n    /**\n     * Decode bytes using a Base64 URL string\n     * @param {string} b64URLStr The Base64 URL string\n     * @return {Uint8Array} Array buffer\n     */\n    public static decodeBytes(b64URLStr: string): Uint8Array {\n        const b64Str = b64URLStr.replace(/-/g, '+').replace(/_/g, '/');\n        const b64StrWithoutPadding = removePadding(b64Str);\n        const arrayBuffer = Uint8Array.from(atob(b64StrWithoutPadding), (c) => c.charCodeAt(0));\n        return arrayBuffer;\n    }\n}\n\nconst removePadding = (s: string): string => {\n    const padIdx = s.indexOf('=');\n    return s.slice(0, padIdx === -1 ? s.length : padIdx);\n};\n","import { ICreateCredentialFeatures, Transports } from './types/CredentialTypes';\nimport { asyncCallWithTimeout } from './utils/asyncCallWithTimeout';\nimport BytesHelper from './utils/BytesHelper';\n/**\n * Utility functions that assist in creating WebAuthn credentials.\n */\nexport class CreateCredentialUtils {\n    /**\n     * Uses information about the user's current browser to determine what features are availble for creating credentials via WebAuthn.\n     * @return {Promise<ICreateCredentialFeatures>} The set of features supported by the browser.\n     */\n    public static async createCredentialAvailable(): Promise<ICreateCredentialFeatures> {\n        const availableFeatures: ICreateCredentialFeatures = {\n            securityKey: false,\n            platform: false,\n            isAvailable: false,\n        };\n        if (window.PublicKeyCredential) {\n            availableFeatures.securityKey = true;\n            availableFeatures.isAvailable = true;\n            await asyncCallWithTimeout(\n                window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n                    .then((available) => {\n                        // If false, webauthn supported, platform auth *not* supported.\n                        // Only get here is platform auth is on, so return false\n                        availableFeatures.platform = available;\n                    })\n                    .catch(() => console.log('Something went wrong.')),\n                1000\n            );\n        }\n\n        return availableFeatures;\n    }\n\n    /**\n     * Decode public key from base64 encoding to Array buffer encoding.\n     * Decodes `publicKey.challenge`, `publicKey.user.id`, and the `id` field from the `publicKey.excludeCredential` list\n     * @param {PublicKeyCredentialCreationOptions} publicKey The base64 encoded public key\n     * @return {PublicKeyCredentialCreationOptions}\n     */\n    public static parsePublicKey(\n        publicKey: PublicKeyCredentialCreationOptions\n    ): PublicKeyCredentialCreationOptions {\n        publicKey.challenge = BytesHelper.decodeBytes(publicKey.challenge.toString());\n        publicKey.user.id = BytesHelper.decodeBytes(publicKey.user.id.toString());\n        if (publicKey.excludeCredentials) {\n            for (let i = 0; i < publicKey.excludeCredentials.length; i++) {\n                const e = publicKey.excludeCredentials[i];\n                e.id = BytesHelper.decodeBytes(e.id.toString());\n            }\n        }\n        return publicKey;\n    }\n\n    /**\n     * After creating a credential hints about what type of authenticator was used in the creattion of a credential. This information should\n     * be stored on the backend and returned in the allowed credentials list for a get credential operation when logging in.\n     * Not all browsers support getting Transport information, in that case return value will be an empty array.\n     * See more at https://w3c.github.io/webauthn/#enum-transport\n     * @param {PublicKeyCredential} credential The crednetial created by navigator.credentials.create\n     * @return {Transports[]} The hints about what type of authenticator was used to create a credential.\n     */\n    public static getTransports(credential: PublicKeyCredential): Transports[] {\n        let transports: Transports[] = [];\n        // getTransports() is not defined in all browsers (i.e. Firefox)\n        // make sure the function is defined before trying to use it\n        if (\n            // @ts-ignore\n            credential.response.getTransports &&\n            // @ts-ignore\n            typeof credential.response.getTransports === 'function'\n        ) {\n            // @ts-ignore\n            transports = credential.response.getTransports();\n        }\n        return transports;\n    }\n\n    /**\n     * Peforms parsePublicKey, navigator.credentials.create, and getTransports to create a new WebAuthn credential.\n     * This function can throw exceptions if the call to navigator.credentials.create times out or the user cancels the operation.\n     * @param {PublicKeyCredentialCreationOptions} publicKey The base64 encoded public key\n     * @return {Promise<{credential: (PublicKeyCredential | null), transports: Transports[]}>} A promise containing the created credential and\n     */\n    public static async createCredential(\n        publicKey: PublicKeyCredentialCreationOptions\n    ): Promise<{ credential: PublicKeyCredential | null; transports: Transports[] }> {\n        const result: { credential: PublicKeyCredential | null; transports: Transports[] } = {\n            credential: null,\n            transports: [],\n        };\n\n        const parsedPublicKey = this.parsePublicKey(publicKey);\n        const credential: PublicKeyCredential | null = await navigator.credentials\n            .create({\n                publicKey: parsedPublicKey,\n            })\n            .then((credValue) => {\n                return credValue as PublicKeyCredential;\n            });\n        if (credential == null) {\n            return result;\n        }\n        result.credential = credential;\n        result.transports = this.getTransports(credential);\n\n        return result;\n    }\n}\n","import UaParser from 'ua-parser-js';\n/**\n * BrowserHelper assists in detecting what features the browser supports\n */\nexport default class BrowserHelper {\n    userAgent: UaParser.UAParserInstance;\n\n    /**\n     * Constructor configuring the CredentialHelper class' attributes\n     */\n    constructor() {\n        this.userAgent = new UaParser();\n    }\n\n    /**\n     * Detects if the browser can talk to a cloud-backed credential provider, like iCloud or Google Password Manager\n     * @return {boolean}\n     */\n    public getSyncedCredential(): boolean {\n        // iOS Supported\n        if (this._isiOSPasskeySupported()) {\n            return true;\n        }\n\n        // MacOS Safari Supported\n        if (this._isMacPasskeySupported()) {\n            return true;\n        }\n\n        if (this._isChromeSyncedCredential()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determines if the browser is capable of showing a UI to load a credential from another device, usually a QR code\n     * @return {boolean}\n     */\n    public getCrossDeviceCredential(): boolean {\n        if (this.userAgent.getOS().name === 'Android') {\n            return false;\n        }\n        return this.getSyncedCredential();\n    }\n\n    /**\n     * Detect if Browser is running on iOS16 or greater\n     * @return {boolean}\n     */\n    private _isiOSPasskeySupported(): boolean {\n        return (\n            this.userAgent.getOS().name == 'iOS' &&\n            parseFloat(this.userAgent.getOS().version || '') >= 16\n        );\n    }\n\n    /**\n     * Detect if Browser is running MacOS and Safari 16 or greater\n     * @return {boolean}\n     */\n    private _isMacPasskeySupported(): boolean {\n        return (\n            this.userAgent.getBrowser().name == 'Safari' &&\n            parseFloat(this.userAgent.getBrowser().version || '') >= 16 &&\n            this.userAgent.getOS().name == 'Mac OS'\n        );\n    }\n\n    /**\n     * Detect if Browser is running Chrome 108 desktop or greater\n     * @return {boolean}\n     */\n    private _isChromeSyncedCredential(): boolean {\n        const os = this.userAgent.getOS().name ?? '';\n        const supportedOS =\n            os?.includes('Windows') || os?.includes('Mac OS') || os?.includes('Android');\n        return (\n            supportedOS &&\n            this.userAgent.getBrowser().name == 'Chrome' &&\n            parseFloat(this.userAgent.getBrowser().version || '') >= 108\n        );\n    }\n}\n","import BytesHelper from './utils/BytesHelper';\nimport { CreateCredentialUtils } from './CreateCredentialUtils';\nimport { IGetCredentialFeatures } from './types/CredentialTypes';\nimport BrowserHelper from './utils/BrowserHelper';\n\n/**\n * Utility functions that assist in getting previously created WebAuthn credentials.\n */\nexport class GetCredentialUtils {\n    /**\n     * Decode public key from base64 encoding to Array buffer encoding.\n     * Decodes `publicKey.challenge`, and the `id` field from the `publicKey.allowCredentials` list\n     * @param {PublicKeyCredentialRequestOptions} publicKey The base64 encoded public key\n     * @return {PublicKeyCredentialRequestOptions}\n     */\n    public static parsePublicKey(\n        publicKey: PublicKeyCredentialRequestOptions\n    ): PublicKeyCredentialRequestOptions {\n        publicKey.challenge = BytesHelper.decodeBytes(publicKey.challenge.toString());\n        if (publicKey.allowCredentials) {\n            for (let i = 0; i < publicKey.allowCredentials.length; i++) {\n                const e = publicKey.allowCredentials[i];\n                e.id = BytesHelper.decodeBytes(e.id.toString());\n            }\n            return publicKey;\n        }\n        return publicKey;\n    }\n\n    /**\n     * Performs parsePublicKey and navigator.credentials.get to get a previously created credential assertion\n     * This function can throw exceptions if the call to navigator.credentials.get times out or the user cancels the operation.\n     * @param {PublicKeyCredentialRequestOptions} publicKey The base64 encoded public key\n     * @param {object} options Additional options to control mediation type and an AbortSignal\n     * @return {Promise<(PublicKeyCredential | null)>} The assertion to validate against a WebAuthn finish backend call\n     */\n    public static async getCredential(\n        publicKey: PublicKeyCredentialRequestOptions,\n        options?: {\n            mediation?: string;\n            signal?: AbortSignal;\n        }\n    ): Promise<PublicKeyCredential | null> {\n        const assertion: PublicKeyCredential | null = await navigator.credentials\n            .get({\n                mediation: options?.mediation as CredentialMediationRequirement,\n                signal: options?.signal,\n                publicKey: this.parsePublicKey(publicKey),\n            })\n            .then((credValue) => {\n                return credValue as PublicKeyCredential;\n            });\n        return assertion;\n    }\n\n    /**\n     * Uses information about the user's current browser to determine what features are availble for getting credentials via WebAuthn.\n     * @return {Promise<IGetCredentialFeatures>} The set of features supported by the browser.\n     */\n    public static async getCredentialAvailable(): Promise<IGetCredentialFeatures> {\n        const availableFeatures: IGetCredentialFeatures = {\n            securityKey: false,\n            platform: false,\n            syncedCredential: false,\n            crossDeviceCredential: false,\n            conditionalUI: false,\n            isAvailable: false,\n        };\n\n        const createFeatures = await CreateCredentialUtils.createCredentialAvailable();\n        availableFeatures.securityKey = createFeatures.securityKey;\n        availableFeatures.platform = createFeatures.platform;\n        availableFeatures.isAvailable = createFeatures.isAvailable;\n\n        if (!availableFeatures.securityKey) {\n            // if security keys aren't supported, then nothing is\n            return availableFeatures;\n        }\n\n        availableFeatures.conditionalUI = await this._isConditionalMediationAvailable();\n        const browserHelper = new BrowserHelper();\n        availableFeatures.syncedCredential = browserHelper.getSyncedCredential();\n        availableFeatures.crossDeviceCredential = browserHelper.getCrossDeviceCredential();\n\n        return availableFeatures;\n    }\n\n    /**\n     * Detects if conditional mediation is supported on this device\n     * @return {Promise<boolean>}\n     */\n    private static async _isConditionalMediationAvailable(): Promise<boolean> {\n        // @ts-ignore\n        if (!PublicKeyCredential.isConditionalMediationAvailable) {\n            return false;\n        }\n        // @ts-ignore\n        return await PublicKeyCredential.isConditionalMediationAvailable();\n    }\n}\n"],"mappings":"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","names":["src_exports","__export","CreateCredentialUtils","GetCredentialUtils","__toCommonJS","asyncCallWithTimeout","asyncPromise","timeLimit","__async","timeoutHandle","timeoutPromise","resolve","result","BytesHelper","arrayBuffer","b64URLStr","removePadding","b64Str","b64StrWithoutPadding","c","s","padIdx","CreateCredentialUtils","__async","availableFeatures","asyncCallWithTimeout","available","publicKey","BytesHelper","i","e","credential","transports","result","parsedPublicKey","credValue","import_ua_parser_js","BrowserHelper","UaParser","_a","os","GetCredentialUtils","publicKey","BytesHelper","i","e","options","__async","credValue","availableFeatures","createFeatures","CreateCredentialUtils","browserHelper","BrowserHelper"]}