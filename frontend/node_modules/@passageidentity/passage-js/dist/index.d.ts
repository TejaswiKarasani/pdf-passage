import { IGetCredentialFeatures, ICreateCredentialFeatures } from '@passageidentity/webauthnutils';
import { ErrorObject } from 'serialize-error';

declare enum Identifier {
    email = "email",
    phone = "phone",
    both = "both"
}
declare enum RequiredIdentifier {
    Phone = "phone",
    Email = "email",
    Both = "both",
    Either = "either"
}
declare enum UserMetadataType {
    STRING = "string",
    BOOLEAN = "boolean",
    INTEGER = "integer",
    DATE = "date",
    PHONE = "phone",
    EMAIL = "email"
}
interface UserMetadataSchema {
    id: string;
    field_name: string;
    type: UserMetadataType;
    friendly_name: string;
    registration: boolean;
    profile: boolean;
}
interface UserMetadataLayout {
    id: string;
    x: number;
    y: number;
    w: number;
    h: number;
}
declare enum AllowedFallbackAuth {
    LoginCode = "otp",
    MagicLink = "magic_link",
    None = "none"
}
interface PassageAppInfo {
    name: string;
    id: string;
    auth_origin: string;
    redirect_url: string;
    rsa_public_key: string;
    ephemeral: boolean;
    allowed_identifier: Identifier;
    require_identifier_verification: boolean;
    session_timeout_length: number;
    required_identifier: RequiredIdentifier;
    user_metadata_schema: UserMetadataSchema[];
    layouts: {
        profile: UserMetadataLayout[];
        registration: UserMetadataLayout[];
    };
    public_signup: boolean;
    default_language: string;
    auth_fallback_method: AllowedFallbackAuth;
    auth_fallback_method_ttl: number;
    profile_management: boolean;
    passage_branding: boolean;
}

declare enum PassageUserStatus {
    ACTIVE = "active",
    INACTIVE = "inactive",
    PENDING = "pending"
}
declare enum WebAuthnType {
    Platform = "platform",
    Passkey = "passkey"
}
interface PassageUser {
    id: string;
    webauthn: boolean;
    webauthn_types: WebAuthnType[];
    status: PassageUserStatus;
    email?: string;
    email_verified: boolean;
    phone?: string;
    phone_verified: boolean;
    user_metadata?: object | null;
    hasPasskey: boolean;
}
interface Metadata {
    [key: string]: boolean | string | number;
}
interface CreateUserPayload {
    identifier: string;
    user_metadata?: Metadata;
}

interface PassageMagicLinkRequest {
    id: string;
}

interface PassageOneTimePasscodeRequest {
    otp_id: string;
}

interface PassageDevice {
    id: string;
    cred_id: string;
    friendly_name: string;
    usage_count: number;
    updated_at: string;
    created_at: string;
    last_login_at: string;
    type: WebAuthnType;
    user_id: string;
}

interface PassageUserInfo {
    created_at: string;
    update_at: string;
    status: string;
    id: string;
    email: string;
    email_verified: boolean;
    phone: string;
    phone_verified: boolean;
    webauthn: boolean;
    webauthn_devices: PassageDevice[];
    last_login_at: string;
    login_count: number;
    user_metadata: Metadata | null;
    webauthn_types: WebAuthnType[];
}

interface PassageEditDeviceRequest {
    friendly_name: string;
}

/**
 * Base class for implementing read-only token stores. getAuthToken() is the only required function to implement.
 * If a Passage object is built with a read-only token store it will not handle any token storage.
 */
declare abstract class ReadOnlyTokenStore {
    /**
     * This method returns a token to be used for authenticated operations on the User class.
     * This can return a Passage-issued JWT or a third-party bearer token for use with authorizers.
     * @returns {Promise<string>} Passage-issued JWT or third-party bearer token
     */
    abstract getAuthToken(): Promise<string>;
    /**
     * This method retrieves a Passage refresh token from storage for use with the Session class for refreshing Passage sessions.
     * If this method returns undefined then Session will not handle any refresh token logic.
     * Only return Passage-issued refresh tokens from this method.
     * @return {Promise<string | undefined>} refresh token, or undefined if not using refresh tokens.
     */
    getRefreshToken(): Promise<string | undefined>;
}
/**
 * Base class for implementing full read-write token stores.
 */
declare abstract class TokenStore extends ReadOnlyTokenStore {
    /**
     * This method is responsible for hanlding the storage of Passage-issues JWTs and refresh tokens.
     * @param {authResult} authResult The authResult object returned from Passage Login, Register, Magic Link, and token refresh operations.
     */
    abstract setTokens(authResult: authResult): Promise<void>;
    /**
     * This method is responsible for clearing tokens from storage when a sign-out operation is executed on the Session class.
     * @return {Promise<void>}
     */
    clearTokens(): Promise<void>;
}
declare class PassageTokenStore extends TokenStore {
    private noLocalStorage;
    private noLocalStorageError;
    getAuthToken(): Promise<string>;
    private setAuthToken;
    getRefreshToken(): Promise<string | undefined>;
    setRefreshToken(refreshToken: string): Promise<void>;
    setTokens(authResult: authResult): Promise<void>;
    clearTokens(): Promise<void>;
    /**
     * Determines if localhost
     * @return {boolean} The sum of the two numbers.
     */
    private _isLocalHost;
    /**
     * Determines if protocol being used is HTTPS
     * @return {boolean}
     */
    private _isHttps;
}
declare function isFullTokenStore(store: ReadOnlyTokenStore | TokenStore): store is TokenStore;

/**
 * The User class used to retrieve information about a Passage User.
 */
declare class User {
    private tokenStore;
    private apiUrl;
    private session;
    /**
     * constructor for the User class.
     * @param {string} [appID] the App's corresponding AppID
     * @param {ReadOnlyTokenStore | TokenStore} [tokenStore] A tokenStore object that enables getting Passage User information from an externally stored token.
     */
    constructor(appID: string, tokenStore: TokenStore | ReadOnlyTokenStore);
    /**
     * userInfo returns the user information for the currently authenticated user.
     * @return {PassageCurrentUser | undefined} the current Passage user's info, or undefined if the
     * current Passage user's authentication token could not be validated.
     */
    userInfo(): Promise<PassageUserInfo | undefined>;
    /**
     * changeEmail initiate an email change for the authenticated user. An email change requires verification, so an email will be sent to the user which they must verify before the email change takes effect.
     * @param {string} newEmail
     * @param {string?} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {PassageMagicLinkRequest} the magicLink response on success.
     */
    changeEmail(newEmail: string, language?: string): Promise<PassageMagicLinkRequest>;
    /**
     * changePhone initiates a phone number change for the authenticated user. An phone number change requires verification, so an SMS with a link will be sent to the user which they must verify before the phone number change takes effect.
     * @param {string} newPhone
     * @param {string?} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {PassageMagicLinkRequest} the magicLink response on success.
     */
    changePhone(newPhone: string, language?: string): Promise<PassageMagicLinkRequest>;
    /**
     * editDevice is used to edit the current user's device attributes such as device_name
     * @param {string} deviceID
     * @param {PassageEditDeviceRequest} editDeviceRequest
     * @return {PassageDevice} the edited device after applying the requested device attribute changes.
     */
    editDevice(deviceID: string, editDeviceRequest: PassageEditDeviceRequest): Promise<PassageDevice>;
    /**
     * listDevices is used to list the current user's devices.
     * @param {string} deviceID
     * @param {PassageEditDeviceRequest} editDeviceRequest
     * @return {PassageDevice[]} the array of devices.
     */
    listDevices(): Promise<PassageDevice[]>;
    /**
     * addDevice is used to add a new webAuthn device for the current user.
     * @return {PassageDevice} the new webAuthn device registered with Passage.
     */
    addDevice(): Promise<PassageDevice>;
    /**
     * deleteDevice deletes an existing webAuthn device for the current user.
     * @param {string | PassageDevice} deviceID the ID of the device to be deleted or a PassageDevice object
     * @return {boolean} true if the device has been deleted successfully.
     */
    deleteDevice(deviceID: string | PassageDevice): Promise<boolean>;
    /**
     * getMetadata returns the metadata for the currently authenticated user.
     * @return {Metadata | undefined} the current Passage user's info, or undefined if the
     * current Passage user's authentication token could not be validated.
     */
    getMetadata(): Promise<Metadata | undefined>;
    /**
     * updateMetadata updates the metadata for the currentuser. Note that only metadata fields set for the app can be updated.
     * @param {Metadata} metadata
     * @return {PassageUser} the current user with their newly updated metadata field.
     */
    updateMetadata(metadata: Metadata): Promise<PassageUser>;
    /**
     * Parse the public key via credential creation options.
     * @param {PublicKeyCredentialCreationOptions} publicKey
     * @return {PublicKeyCredentialCreationOptions}
     */
    private _parsePublicKey;
    /**
     * Returns the external token if used or gets the current auth token, and performs a refresh operation if necessary.
     * @return {Promise<string>}
     */
    private _getToken;
}

interface BrowserInfo {
    createPassKeySupported: boolean;
    getPassKeySupported: boolean;
    conditionalUISupported: boolean;
}

/**
 * The Session class used to manage Passage sessions using refresh tokens.
 */
declare class Session {
    private tokenStore;
    private apiUrl;
    /**
     * Session constructor initializing apiURL and identifier class vars
     * @param {string} [appID] the App's corresponding AppID
     * @param {ReadOnlyTokenStore | TokenStore} [tokenStore] A tokenStore object that enables getting Passage User information from an externally stored token.
     * If the tokenStore implements the full TokenStore class, the Session will handle refreshing Passage sessions via the refresh token.
     */
    constructor(appID: string, tokenStore: TokenStore | ReadOnlyTokenStore);
    /**
     * authGuard checks if the current user has a JWT that is valid and potentially verifiable.
     * IMPORTANT: this is not verifying the JWT, it is only checking if the JWT is formatted properly.
     * @return {boolean} true if the user has a valid (but unverified) JWT, false if not.
     */
    authGuard(): Promise<boolean>;
    /**
     * Sign out a user by deleting their AuthToken from local storage and revoking their refresh token.
     * @return {boolean} true if the device has been deleted successfully.
     */
    signOut(): Promise<boolean>;
    /**
     * getAuthToken gets the current authToken for the currently authenticated user.
     * @return {string} returns the user's authToken if it exists or fetches a new one with a refresh token if it exists
     */
    getAuthToken(): Promise<string>;
    /**
     * refresh gets and saves a new authToken for the currently authenticated user using their refresh token
     * @return {string} returns the user's authToken if successful
     */
    refresh(): Promise<authResult>;
    /**
     * _validJWTPayload checks to see if the current JWT is valid (formatted as expected and isn't expired).
     * @param {JwtPayload} payload the payload from the JWT.
     * @return {boolean} true if the JWT payload is valid, false if not.
     */
    private _validJWTPayload;
    /**
     * _validJWTHeader checkts to see if the JWT header is valid (formatted as expected).
     * @param {JwtHeader} header the header from the JWT.
     * @return {boolean} true if the JWT header is valid, false if not.
     */
    private _validJWTHeader;
}

interface PassageConfig {
    tokenStore?: ReadOnlyTokenStore | TokenStore;
}

interface authResult {
    redirect_url: string;
    auth_token: string;
    refresh_token?: string;
}
/**
 * The Passage class used to perform register and login operations.
 * The only parameter is the app handle for the application.
 *
 * @example
 * ```
 * import Passage from '@passageidentity/passage-js';
 * const passage = new Passage(app_id);
 * ```
 */
declare class Passage {
    private appID;
    fullUrl: string;
    private tokenStore;
    /**
     * Constructor configuring the Passage class' attributes
     * @param {string} appID the App's corresponding AppID
     * @param {PassageConfig | undefined} config An optional parameter to pass in a configurable properties.
     * The tokenStore property is an object that implementes ReadOnlyTokenStore or TokenStore to manage retrieval and storage of tokens.
     * If no tokenStore is provided by default Passage will store tokens in a combination of localstorage and cookies.
     */
    constructor(appID: string, config?: PassageConfig);
    /**
     * Check to see if the credentialID exists in localStorage via
     * the key psg_cred_obj.
     * @param {string} userID the Passage User's userID
     * @return {boolean} returns true if psg_cred_obj exists in localstorage, false if not
     */
    credIDExists(userID: string): boolean;
    /**
     * Passage will attempt a webauthn register for the new user, which will return a webauthn challenge.
     * Webauthn register is a two step process to create a credential. Successful response is a JSON object with the redirect URL.
     *
     * @param {string} identifier email address / phone for user
     * @return {Promise<authResult>} a data object that includes a redirect URL and sets the `psg_auth_token` in local storage.
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js';
     *
     * const passage = new Passage(app_id);
     * const identifier = document.getElementById(<"email" | "phone">).value;
     *
     * await passage.register(identifier)
     *   .then(res => {
     *       // on succes, redirect. auth token set in local storage
     *       location.href(res.redirectURL);
     *   })
     *   .catch(e => console.log(e));
     * ```
     */
    register(identifier: string): Promise<authResult>;
    /**
     * Passage will attempt a webauthn login for an existing user, which will return a webauthn challenge.
     * Webauthn login is a two step process to retrieve and verify the credential.
     *
     * @param {string} identifier email address / phone for user
     * @return {Promise<authResult>} a data object that includes a redirect URL and sets the `psg_auth_token` in local storage.
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js';
     *
     * const passage = new Passage(app_id);
     * const identifier = document.getElementById(<"email" | "phone">).value;
     *
     * await passage.login(identifier)
     *   .then(res => {
     *       // on succes, redirect. auth token set in local storage
     *       location.href(res.redirectURL);
     *   })
     *   .catch(e => console.log(e));
     * ```
     */
    login(identifier: string): Promise<authResult>;
    /**
     * Begin a conditional mediation login.
     * @param {AbortSignal} signal An AbortSignal to cancel a conditional mediation operation
     * @return {Promise<authResult>} a data object that includes a redirect URL and sets the `psg_auth_token` in local storage.
     */
    loginConditional(signal?: AbortSignal): Promise<authResult>;
    /**
     * Get information about an app.
     *
     * @return {Promise<PassageAppInfo>} a data object containing app information and the authentication policy
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js';
     *
     * const passage = new Passage(app_id);
     *
     * await passage.appInfo
     *  .then(data => {
     *      // look at information regarding a particular app
     *  }).catch(e => console.log(e));
     * ```
     */
    appInfo(): Promise<PassageAppInfo>;
    /**
     * @deprecated Switch to using the newer getCredentialAvailable and createCredentialAvailable functions to get detailed information
     * about the availablity of webauthn features.
     * @return {Promise<BrowserInfo>} a data object containing information about what webauthn operations are supported on the browser.
     */
    browserInfo(): Promise<BrowserInfo>;
    /**
     * Uses information about the user's current browser to determine what features are availble for getting credentials via WebAuthn.
     * NOTE: Do not call this from an event handler where navigator.get or navigator.create is invoked or it will break the required user gesture on iOS web browsers.
     * @return {Promise<IGetCredentialFeatures>} The set of features supported by the browser.
     */
    getCredentialAvailable(): Promise<IGetCredentialFeatures>;
    /**
     * Uses information about the user's current browser to determine what features are availble for creating credentials via WebAuthn.
     * NOTE: Do not call this from an event handler where navigator.get or navigator.create is invoked or it will break the required user gesture on iOS web browsers.
     * @return {Promise<ICreateCredentialFeatures>} The set of features supported by the browser.
     */
    createCredentialAvailable(): Promise<ICreateCredentialFeatures>;
    /**
     * Checks if an application's auth origin matches the current origin on an end user's browser.
     * If this function returns false, webauthn will not work properly on this domain.
     *
     * @param {PassageAppInfo} appInfo JSON body containing app information that is returned from the {appInfo} function
     * @return {boolean} true if webauthn is configured properly, false if not
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js'
     *
     * const passage = new Passage(app_id);
     * const webauthn_support = true;
     * const identifier = document.getElementById(<"email" | "phone">).value;
     *
     * await passage.appInfo
     *   .then(res => {
     *       webauthn_supported = passage.checkWebauthnConfig(res)
     *   }).catch(e => console.log(e));
     *
     * if (webauthn_supported) {
     *   await passage.login(identifier)
     *       .then(data => {
     *           ...
     *   }).catch(e => console.log(e));
     * }
     * ```
     */
    checkWebauthnConfig(appInfo: PassageAppInfo): boolean;
    /**
     * @deprecated Switch to using the newer getCredentialAvailable and createCredentialAvailable functions to get detailed information
     * about the availablity of webauthn features.
     * @param {boolean} roaming if we should allow roaming authenticators (Passage does not support roaming authenticators and must be false)
     * @return {boolean} true if webauthn is supported on this device, false if not
     */
    isWebauthnSupported(roaming: boolean): Promise<boolean>;
    /**
     * Look-up an identifier and return the user if the identifier exists
     * @param {string} identifier email address / phone for user
     * @return {Promise<PassageUser>}
     */
    identifierExists(identifier: string): Promise<PassageUser>;
    /**
     * Create a new Passage magic link for registration
     * @param {string} identifier The Passage User's identifier
     * @param {string} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {Promise<PassageMagicLinkRequest>} MagicLink JSON payload
     */
    newRegisterMagicLink(identifier: string, language?: string): Promise<PassageMagicLinkRequest>;
    /**
     * Initiate new login with Passage Magic Link
     * @param {string} identifier The Passage User's identifier
     * @param {string} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {Promise<PassageMagicLinkRequest>} MagicLink JSON payload
     */
    newLoginMagicLink(identifier: string, language?: string): Promise<PassageMagicLinkRequest>;
    /**
     * Activate a magic link when a user clicks the link. This function handles login and registration magic links.
     *
     * @param {string} userMagicLink
     * @return {Promise<authResult>} equivalent to a login operation and will return a redirect_url and set the `psg_auth_token` in Local Storage
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js';
     *
     * const passage = new Passage(app_id);
     *
     * await this.passage.magicLinkActivate(token)
     *      .then((res: any) => {
     *          location.href = res.redirectURL;
     *      })
     *      .catch(() => console.log("access token is invalid or has expired"));
     * ```
     */
    magicLinkActivate(userMagicLink: string): Promise<authResult>;
    /**
     * Activate Passage MagicLink via webAuthn login
     * @param {string} userMagicLink The current magicLink
     * @return {Promise<authResult>} The authentication result
     */
    magicLinkActivateWebAuthnLogin(userMagicLink: string): Promise<authResult>;
    /**
     * Activate Passage MagicLink via webAuthn for a new device
     * @param {string} userMagicLink The current magicLink
     * @return {Promise<authResult>} The authentication result
     */
    magicLinkActivateWebAuthnNewDevice(userMagicLink: string): Promise<authResult>;
    /**
     * Look up a magic link by ID and check if it has been verified. This function is mostly commonly used to
     * iteratively check if a user has clicked a magic link to login. Once the link has been verified,
     * Passage will return authentication information via this endpoint. This enables cross-device login.
     *
     * @param {string} id unique ID for an magic link which is returned by functions that create a magic link
     * @return {Promise<authResult>}
     */
    getMagicLinkStatus(id: string): Promise<authResult>;
    /**
     * Create a new Passage one time passcode for registration
     * @param {string} identifier The Passage User's identifier
     * @param {string} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {Promise<PassageOneTimePasscodeRequest>} One Time Passcode JSON payload
     */
    newRegisterOneTimePasscode(identifier: string, language?: string): Promise<PassageOneTimePasscodeRequest>;
    /**
     * Initiate new login with Passage One Time Passcode
     * @param {string} identifier The Passage User's identifier
     * @param {string} language the language string for localizing emails, if no lanuage or an invalid language is provided the application default lanuage will be used
     * @return {Promise<PassageOneTimePasscodeRequest>} One Time Passcode JSON payload
     */
    newLoginOneTimePasscode(identifier: string, language?: string): Promise<PassageOneTimePasscodeRequest>;
    /**
     * Activate a one time passcode when a user fills out the one time passcode input. This function handles login and registration one time passcodes.
     *
     * @param {string} otp
     * @param {string} otpId
     * @return {Promise<authResult>} equivalent to a login operation and will return a redirect_url and set the `psg_auth_token` in Local Storage
     *
     * @example
     * ```javascript
     * import Passage from '@passageidentity/passage-js';
     *
     * const passage = new Passage(app_id);
     *
     * await this.passage.oneTimePasscodeActivate(oneTimePasscode)
     *      .then((res: any) => {
     *          location.href = res.redirectURL;
     *      })
     *      .catch(() => console.log("access token is invalid or has expired"));
     * ```
     */
    oneTimePasscodeActivate(otp: string, otpId: string): Promise<authResult>;
    /**
     * getCurrentUser returns the current authenticated user.
     * @return {User} the Passage User
     */
    getCurrentUser(): User;
    /**
     * getCurrentSession returns a Session object to manage the current user's session.
     * @return {Session} the Passage Session
     */
    getCurrentSession(): Session;
    /**
     * createUser creates a user in a 'pending' state.
     * @param {CreateUserPayload} [payload] identifier and any optional user_metadata (where registration is set to true) to create the user in a pending state.
     * @return {Promise<PassageUser>}
     */
    createUser(payload: CreateUserPayload): Promise<PassageUser>;
}

type AtLeast<T, K extends keyof T> = Partial<T> & Pick<T, K>;
type RequiredResponse = Partial<Response> & AtLeast<Response, 'status' | 'statusText'>;
/**
 * PassageError assists with error handling.
 */
declare class PassageError extends Error {
    statusCode: number;
    statusText: string;
    message: string;
    name: string;
    /**
     * @param {string} psgErrorResponse a custom Passage error message.
     * @param {RequiredResponse} res response or status and statusText used to generate error.
     */
    constructor(psgErrorResponse: string, res: RequiredResponse);
    /**
     * _poarsePsgErrorResponse parses the custom Passage error response message.
     * @param {any} psgErrorResponse the custom Passage error response.
     * @return {string} the Passage error response from server or input string.
     */
    private _parsePsgErrorResponse;
}
declare enum PassageErrorCode {
    /** The request has more than one possible response. The user agent or user should choose one of them. */
    MultipleChoice = 300,
    /** The URL of the requested resource has been changed permanently. The new URL is given in the response. */
    MovedPermanantly = 301,
    /** This response code means that the URI of requested resource has been changed temporarily. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests. */
    Found = 302,
    /** The server sent this response to direct the client to get the requested resource at another URI with a GET request. */
    SeeOther = 303,
    /** This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response. */
    NotModified = 304,
    /** The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request. */
    TemporaryRedirect = 307,
    /** This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request. */
    PermanentRedirect = 308,
    /** The server could not understand the request due to invalid syntax. */
    BadRequest = 400,
    /** Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response. */
    Unauthorized = 401,
    /** This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists. */
    PaymentRequired = 402,
    /** The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401 Unauthorized, the client's identity is known to the server. */
    Forbidden = 403,
    /** The server can not find the requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 Forbidden to hide the existence of a resource from an unauthorized client. */
    NotFound = 404,
    /** The request method is known by the server but is not supported by the target resource. For example, an API may not allow calling DELETE to remove a resource. */
    MethodNotAllowed = 405,
    /** This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content that conforms to the criteria given by the user agent. */
    NotAcceptable = 406,
    /** This is similar to 401 Unauthorized but authentication is needed to be done by a proxy. */
    ProxyAuthenticationRequired = 407,
    /** This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message. */
    RequestTimeout = 408,
    /** This response is sent when a request conflicts with the current state of the server. */
    Conflict = 409,
    /** This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code. */
    Gone = 410,
    /** Server rejected the request because the Content-Length header field is not defined and the server requires it. */
    LengthRequired = 411,
    /** The client has indicated preconditions in its headers which the server does not meet. */
    PreconditionFailed = 412,
    /** Request entity is larger than limits defined by server. The server might close the connection or return an Retry-After header field. */
    PayloadTooLarge = 413,
    /** The URI requested by the client is longer than the server is willing to interpret. */
    URITooLong = 414,
    /** The media format of the requested data is not supported by the server, so the server is rejecting the request. */
    UnsupportedMediaType = 415,
    /** The range specified by the Range header field in the request cannot be fulfilled. It's possible that the range is outside the size of the target URI's data. */
    RangeNotSatisfiable = 416,
    /** This response code means the expectation indicated by the Expect request header field cannot be met by the server. */
    ExpectationFailed = 417,
    /** The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI. */
    MisdirectedRequest = 421,
    /** The request was well-formed but was unable to be followed due to semantic errors. */
    UnprocessableEntity = 422,
    /** The resource that is being accessed is locked. */
    Locked = 423,
    /** The request failed due to failure of a previous request. */
    FailedDependency = 424,
    /** Indicates that the server is unwilling to risk processing a request that might be replayed. */
    TooEarly = 425,
    /** The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an Upgrade header in a 426 response to indicate the required protocol(s). */
    UpgradeRequired = 426,
    /** The origin server requires the request to be conditional. This response is intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict. */
    PreconditionRequired = 428,
    /** The user has sent too many requests in a given amount of time ("rate limiting"). */
    TooManyRequests = 429,
    /** The server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields. */
    RequestHeaderFieldsTooLarge = 431,
    /** The user agent requested a resource that cannot legally be provided, such as a web page censored by a government. */
    UnavailableForLegalReasons = 451,
    /** The server has encountered a situation it does not know how to handle. */
    InternalServerError = 500,
    /** The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD. */
    NotImplemented = 501,
    /** This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response. */
    BadGateway = 502,
    /** The server is not ready to handle the request. */
    ServiceUnavailable = 503,
    /** This error response is given when the server is acting as a gateway and cannot get a response in time. */
    GatewayTimeout = 504,
    /** The HTTP version used in the request is not supported by the server. */
    HTTPVersionNotSupported = 505,
    /** The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process. */
    VariantAlsoNegotiates = 506,
    /** The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. */
    InsufficientStorage = 507,
    /** The server detected an infinite loop while processing the request. */
    LoopDetected = 508,
    /** Further extensions to the request are required for the server to fulfill it. */
    NotExtended = 510,
    /** Indicates that the client needs to authenticate to gain network access. */
    NetworkAuthenticationRequired = 511,
    /** The psg_cred_obj does not exist in the webAuthn allow list */
    PSGCredObjectDoesNotExist = 700,
    /** Parsing the public key for new device has failed */
    PSGParsePublicKeyForNewDeviceFailed = 701,
    /** Parsing the public key for login has failed */
    PSGParsePublicKeyForLoginFailed = 702,
    /** Could not get user's credential */
    PSGCouldNotGetUserCredential = 703,
    /** Indicates that the user needs to authenticate */
    PSGLoginRequired = 704
}

type PassageSentryProject = 'passage-js' | 'passage-elements';
interface ISentryConfig {
    url?: string;
    project?: PassageSentryProject;
    dsn?: string;
    environment?: string;
    release?: string;
    version?: string;
}
interface ICaptureEventProps {
    error?: Error | string;
    message?: string;
    sentryConfig?: ISentryConfig;
}
interface CaptureEventBody {
    error?: Error | string;
    serializedError?: ErrorObject;
    message?: string;
    project: PassageSentryProject;
    release?: string;
    dsn?: string;
    environment?: string;
    version?: string;
}
declare const cleanSentryConfig: (config: ISentryConfig) => ISentryConfig;
declare const captureEvent: (props: ICaptureEventProps) => Promise<void>;

export { AllowedFallbackAuth, BrowserInfo, CaptureEventBody, CreateUserPayload, ICaptureEventProps, ISentryConfig, Identifier, Metadata, Passage, PassageAppInfo, PassageDevice, PassageEditDeviceRequest, PassageError, PassageErrorCode, PassageMagicLinkRequest, PassageSentryProject, PassageTokenStore, PassageUser, PassageUserInfo, PassageUserStatus, ReadOnlyTokenStore, RequiredIdentifier, Session, TokenStore, User, UserMetadataLayout, UserMetadataSchema, UserMetadataType, WebAuthnType, authResult, captureEvent, cleanSentryConfig, isFullTokenStore };
