var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import { a1 as commonjsGlobal, d as defineComponent, f as ref, i as computed, _ as _export_sfc, o as openBlock, c as createElementBlock, w as withDirectives, a2 as vModelCheckbox, a as createBaseVNode, p as normalizeClass, n as withModifiers, t as toDisplayString, h as useLocale, q as vModelText, a3 as dayjs, a4 as resolveComponent, F as createVNode, j as onMounted, g as watch, v as vShow, L as useDefaultCountryCode, a5 as ce, N as Fragment, P as renderList, b as createBlock, X as resolveDynamicComponent, Y } from "./customElements.es.js";
var intlTelInput$1 = { exports: {} };
(function(module) {
  (function(factory) {
    if (module.exports)
      module.exports = factory();
    else
      window.intlTelInput = factory();
  })(function(undefined$1) {
    return function() {
      var allCountries = [["Afghanistan (\u202B\u0627\u0641\u063A\u0627\u0646\u0633\u062A\u0627\u0646\u202C\u200E)", "af", "93"], ["Albania (Shqip\xEBri)", "al", "355"], ["Algeria (\u202B\u0627\u0644\u062C\u0632\u0627\u0626\u0631\u202C\u200E)", "dz", "213"], ["American Samoa", "as", "1", 5, ["684"]], ["Andorra", "ad", "376"], ["Angola", "ao", "244"], ["Anguilla", "ai", "1", 6, ["264"]], ["Antigua and Barbuda", "ag", "1", 7, ["268"]], ["Argentina", "ar", "54"], ["Armenia (\u0540\u0561\u0575\u0561\u057D\u057F\u0561\u0576)", "am", "374"], ["Aruba", "aw", "297"], ["Ascension Island", "ac", "247"], ["Australia", "au", "61", 0], ["Austria (\xD6sterreich)", "at", "43"], ["Azerbaijan (Az\u0259rbaycan)", "az", "994"], ["Bahamas", "bs", "1", 8, ["242"]], ["Bahrain (\u202B\u0627\u0644\u0628\u062D\u0631\u064A\u0646\u202C\u200E)", "bh", "973"], ["Bangladesh (\u09AC\u09BE\u0982\u09B2\u09BE\u09A6\u09C7\u09B6)", "bd", "880"], ["Barbados", "bb", "1", 9, ["246"]], ["Belarus (\u0411\u0435\u043B\u0430\u0440\u0443\u0441\u044C)", "by", "375"], ["Belgium (Belgi\xEB)", "be", "32"], ["Belize", "bz", "501"], ["Benin (B\xE9nin)", "bj", "229"], ["Bermuda", "bm", "1", 10, ["441"]], ["Bhutan (\u0F60\u0F56\u0FB2\u0F74\u0F42)", "bt", "975"], ["Bolivia", "bo", "591"], ["Bosnia and Herzegovina (\u0411\u043E\u0441\u043D\u0430 \u0438 \u0425\u0435\u0440\u0446\u0435\u0433\u043E\u0432\u0438\u043D\u0430)", "ba", "387"], ["Botswana", "bw", "267"], ["Brazil (Brasil)", "br", "55"], ["British Indian Ocean Territory", "io", "246"], ["British Virgin Islands", "vg", "1", 11, ["284"]], ["Brunei", "bn", "673"], ["Bulgaria (\u0411\u044A\u043B\u0433\u0430\u0440\u0438\u044F)", "bg", "359"], ["Burkina Faso", "bf", "226"], ["Burundi (Uburundi)", "bi", "257"], ["Cambodia (\u1780\u1798\u17D2\u1796\u17BB\u1787\u17B6)", "kh", "855"], ["Cameroon (Cameroun)", "cm", "237"], ["Canada", "ca", "1", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde (Kabu Verdi)", "cv", "238"], ["Caribbean Netherlands", "bq", "599", 1, ["3", "4", "7"]], ["Cayman Islands", "ky", "1", 12, ["345"]], ["Central African Republic (R\xE9publique centrafricaine)", "cf", "236"], ["Chad (Tchad)", "td", "235"], ["Chile", "cl", "56"], ["China (\u4E2D\u56FD)", "cn", "86"], ["Christmas Island", "cx", "61", 2, ["89164"]], ["Cocos (Keeling) Islands", "cc", "61", 1, ["89162"]], ["Colombia", "co", "57"], ["Comoros (\u202B\u062C\u0632\u0631 \u0627\u0644\u0642\u0645\u0631\u202C\u200E)", "km", "269"], ["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243"], ["Congo (Republic) (Congo-Brazzaville)", "cg", "242"], ["Cook Islands", "ck", "682"], ["Costa Rica", "cr", "506"], ["C\xF4te d\u2019Ivoire", "ci", "225"], ["Croatia (Hrvatska)", "hr", "385"], ["Cuba", "cu", "53"], ["Cura\xE7ao", "cw", "599", 0], ["Cyprus (\u039A\u03CD\u03C0\u03C1\u03BF\u03C2)", "cy", "357"], ["Czech Republic (\u010Cesk\xE1 republika)", "cz", "420"], ["Denmark (Danmark)", "dk", "45"], ["Djibouti", "dj", "253"], ["Dominica", "dm", "1", 13, ["767"]], ["Dominican Republic (Rep\xFAblica Dominicana)", "do", "1", 2, ["809", "829", "849"]], ["Ecuador", "ec", "593"], ["Egypt (\u202B\u0645\u0635\u0631\u202C\u200E)", "eg", "20"], ["El Salvador", "sv", "503"], ["Equatorial Guinea (Guinea Ecuatorial)", "gq", "240"], ["Eritrea", "er", "291"], ["Estonia (Eesti)", "ee", "372"], ["Eswatini", "sz", "268"], ["Ethiopia", "et", "251"], ["Falkland Islands (Islas Malvinas)", "fk", "500"], ["Faroe Islands (F\xF8royar)", "fo", "298"], ["Fiji", "fj", "679"], ["Finland (Suomi)", "fi", "358", 0], ["France", "fr", "33"], ["French Guiana (Guyane fran\xE7aise)", "gf", "594"], ["French Polynesia (Polyn\xE9sie fran\xE7aise)", "pf", "689"], ["Gabon", "ga", "241"], ["Gambia", "gm", "220"], ["Georgia (\u10E1\u10D0\u10E5\u10D0\u10E0\u10D7\u10D5\u10D4\u10DA\u10DD)", "ge", "995"], ["Germany (Deutschland)", "de", "49"], ["Ghana (Gaana)", "gh", "233"], ["Gibraltar", "gi", "350"], ["Greece (\u0395\u03BB\u03BB\u03AC\u03B4\u03B1)", "gr", "30"], ["Greenland (Kalaallit Nunaat)", "gl", "299"], ["Grenada", "gd", "1", 14, ["473"]], ["Guadeloupe", "gp", "590", 0], ["Guam", "gu", "1", 15, ["671"]], ["Guatemala", "gt", "502"], ["Guernsey", "gg", "44", 1, ["1481", "7781", "7839", "7911"]], ["Guinea (Guin\xE9e)", "gn", "224"], ["Guinea-Bissau (Guin\xE9 Bissau)", "gw", "245"], ["Guyana", "gy", "592"], ["Haiti", "ht", "509"], ["Honduras", "hn", "504"], ["Hong Kong (\u9999\u6E2F)", "hk", "852"], ["Hungary (Magyarorsz\xE1g)", "hu", "36"], ["Iceland (\xCDsland)", "is", "354"], ["India (\u092D\u093E\u0930\u0924)", "in", "91"], ["Indonesia", "id", "62"], ["Iran (\u202B\u0627\u06CC\u0631\u0627\u0646\u202C\u200E)", "ir", "98"], ["Iraq (\u202B\u0627\u0644\u0639\u0631\u0627\u0642\u202C\u200E)", "iq", "964"], ["Ireland", "ie", "353"], ["Isle of Man", "im", "44", 2, ["1624", "74576", "7524", "7924", "7624"]], ["Israel (\u202B\u05D9\u05E9\u05E8\u05D0\u05DC\u202C\u200E)", "il", "972"], ["Italy (Italia)", "it", "39", 0], ["Jamaica", "jm", "1", 4, ["876", "658"]], ["Japan (\u65E5\u672C)", "jp", "81"], ["Jersey", "je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"]], ["Jordan (\u202B\u0627\u0644\u0623\u0631\u062F\u0646\u202C\u200E)", "jo", "962"], ["Kazakhstan (\u041A\u0430\u0437\u0430\u0445\u0441\u0442\u0430\u043D)", "kz", "7", 1, ["33", "7"]], ["Kenya", "ke", "254"], ["Kiribati", "ki", "686"], ["Kosovo", "xk", "383"], ["Kuwait (\u202B\u0627\u0644\u0643\u0648\u064A\u062A\u202C\u200E)", "kw", "965"], ["Kyrgyzstan (\u041A\u044B\u0440\u0433\u044B\u0437\u0441\u0442\u0430\u043D)", "kg", "996"], ["Laos (\u0EA5\u0EB2\u0EA7)", "la", "856"], ["Latvia (Latvija)", "lv", "371"], ["Lebanon (\u202B\u0644\u0628\u0646\u0627\u0646\u202C\u200E)", "lb", "961"], ["Lesotho", "ls", "266"], ["Liberia", "lr", "231"], ["Libya (\u202B\u0644\u064A\u0628\u064A\u0627\u202C\u200E)", "ly", "218"], ["Liechtenstein", "li", "423"], ["Lithuania (Lietuva)", "lt", "370"], ["Luxembourg", "lu", "352"], ["Macau (\u6FB3\u9580)", "mo", "853"], ["North Macedonia (\u041C\u0430\u043A\u0435\u0434\u043E\u043D\u0438\u0458\u0430)", "mk", "389"], ["Madagascar (Madagasikara)", "mg", "261"], ["Malawi", "mw", "265"], ["Malaysia", "my", "60"], ["Maldives", "mv", "960"], ["Mali", "ml", "223"], ["Malta", "mt", "356"], ["Marshall Islands", "mh", "692"], ["Martinique", "mq", "596"], ["Mauritania (\u202B\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627\u202C\u200E)", "mr", "222"], ["Mauritius (Moris)", "mu", "230"], ["Mayotte", "yt", "262", 1, ["269", "639"]], ["Mexico (M\xE9xico)", "mx", "52"], ["Micronesia", "fm", "691"], ["Moldova (Republica Moldova)", "md", "373"], ["Monaco", "mc", "377"], ["Mongolia (\u041C\u043E\u043D\u0433\u043E\u043B)", "mn", "976"], ["Montenegro (Crna Gora)", "me", "382"], ["Montserrat", "ms", "1", 16, ["664"]], ["Morocco (\u202B\u0627\u0644\u0645\u063A\u0631\u0628\u202C\u200E)", "ma", "212", 0], ["Mozambique (Mo\xE7ambique)", "mz", "258"], ["Myanmar (Burma) (\u1019\u103C\u1014\u103A\u1019\u102C)", "mm", "95"], ["Namibia (Namibi\xEB)", "na", "264"], ["Nauru", "nr", "674"], ["Nepal (\u0928\u0947\u092A\u093E\u0932)", "np", "977"], ["Netherlands (Nederland)", "nl", "31"], ["New Caledonia (Nouvelle-Cal\xE9donie)", "nc", "687"], ["New Zealand", "nz", "64"], ["Nicaragua", "ni", "505"], ["Niger (Nijar)", "ne", "227"], ["Nigeria", "ng", "234"], ["Niue", "nu", "683"], ["Norfolk Island", "nf", "672"], ["North Korea (\uC870\uC120 \uBBFC\uC8FC\uC8FC\uC758 \uC778\uBBFC \uACF5\uD654\uAD6D)", "kp", "850"], ["Northern Mariana Islands", "mp", "1", 17, ["670"]], ["Norway (Norge)", "no", "47", 0], ["Oman (\u202B\u0639\u064F\u0645\u0627\u0646\u202C\u200E)", "om", "968"], ["Pakistan (\u202B\u067E\u0627\u06A9\u0633\u062A\u0627\u0646\u202C\u200E)", "pk", "92"], ["Palau", "pw", "680"], ["Palestine (\u202B\u0641\u0644\u0633\u0637\u064A\u0646\u202C\u200E)", "ps", "970"], ["Panama (Panam\xE1)", "pa", "507"], ["Papua New Guinea", "pg", "675"], ["Paraguay", "py", "595"], ["Peru (Per\xFA)", "pe", "51"], ["Philippines", "ph", "63"], ["Poland (Polska)", "pl", "48"], ["Portugal", "pt", "351"], ["Puerto Rico", "pr", "1", 3, ["787", "939"]], ["Qatar (\u202B\u0642\u0637\u0631\u202C\u200E)", "qa", "974"], ["R\xE9union (La R\xE9union)", "re", "262", 0], ["Romania (Rom\xE2nia)", "ro", "40"], ["Russia (\u0420\u043E\u0441\u0441\u0438\u044F)", "ru", "7", 0], ["Rwanda", "rw", "250"], ["Saint Barth\xE9lemy", "bl", "590", 1], ["Saint Helena", "sh", "290"], ["Saint Kitts and Nevis", "kn", "1", 18, ["869"]], ["Saint Lucia", "lc", "1", 19, ["758"]], ["Saint Martin (Saint-Martin (partie fran\xE7aise))", "mf", "590", 2], ["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508"], ["Saint Vincent and the Grenadines", "vc", "1", 20, ["784"]], ["Samoa", "ws", "685"], ["San Marino", "sm", "378"], ["S\xE3o Tom\xE9 and Pr\xEDncipe (S\xE3o Tom\xE9 e Pr\xEDncipe)", "st", "239"], ["Saudi Arabia (\u202B\u0627\u0644\u0645\u0645\u0644\u0643\u0629 \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629\u202C\u200E)", "sa", "966"], ["Senegal (S\xE9n\xE9gal)", "sn", "221"], ["Serbia (\u0421\u0440\u0431\u0438\u0458\u0430)", "rs", "381"], ["Seychelles", "sc", "248"], ["Sierra Leone", "sl", "232"], ["Singapore", "sg", "65"], ["Sint Maarten", "sx", "1", 21, ["721"]], ["Slovakia (Slovensko)", "sk", "421"], ["Slovenia (Slovenija)", "si", "386"], ["Solomon Islands", "sb", "677"], ["Somalia (Soomaaliya)", "so", "252"], ["South Africa", "za", "27"], ["South Korea (\uB300\uD55C\uBBFC\uAD6D)", "kr", "82"], ["South Sudan (\u202B\u062C\u0646\u0648\u0628 \u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "ss", "211"], ["Spain (Espa\xF1a)", "es", "34"], ["Sri Lanka (\u0DC1\u0DCA\u200D\u0DBB\u0DD3 \u0DBD\u0D82\u0D9A\u0DCF\u0DC0)", "lk", "94"], ["Sudan (\u202B\u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "sd", "249"], ["Suriname", "sr", "597"], ["Svalbard and Jan Mayen", "sj", "47", 1, ["79"]], ["Sweden (Sverige)", "se", "46"], ["Switzerland (Schweiz)", "ch", "41"], ["Syria (\u202B\u0633\u0648\u0631\u064A\u0627\u202C\u200E)", "sy", "963"], ["Taiwan (\u53F0\u7063)", "tw", "886"], ["Tajikistan", "tj", "992"], ["Tanzania", "tz", "255"], ["Thailand (\u0E44\u0E17\u0E22)", "th", "66"], ["Timor-Leste", "tl", "670"], ["Togo", "tg", "228"], ["Tokelau", "tk", "690"], ["Tonga", "to", "676"], ["Trinidad and Tobago", "tt", "1", 22, ["868"]], ["Tunisia (\u202B\u062A\u0648\u0646\u0633\u202C\u200E)", "tn", "216"], ["Turkey (T\xFCrkiye)", "tr", "90"], ["Turkmenistan", "tm", "993"], ["Turks and Caicos Islands", "tc", "1", 23, ["649"]], ["Tuvalu", "tv", "688"], ["U.S. Virgin Islands", "vi", "1", 24, ["340"]], ["Uganda", "ug", "256"], ["Ukraine (\u0423\u043A\u0440\u0430\u0457\u043D\u0430)", "ua", "380"], ["United Arab Emirates (\u202B\u0627\u0644\u0625\u0645\u0627\u0631\u0627\u062A \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0645\u062A\u062D\u062F\u0629\u202C\u200E)", "ae", "971"], ["United Kingdom", "gb", "44", 0], ["United States", "us", "1", 0], ["Uruguay", "uy", "598"], ["Uzbekistan (O\u02BBzbekiston)", "uz", "998"], ["Vanuatu", "vu", "678"], ["Vatican City (Citt\xE0 del Vaticano)", "va", "39", 1, ["06698"]], ["Venezuela", "ve", "58"], ["Vietnam (Vi\u1EC7t Nam)", "vn", "84"], ["Wallis and Futuna (Wallis-et-Futuna)", "wf", "681"], ["Western Sahara (\u202B\u0627\u0644\u0635\u062D\u0631\u0627\u0621 \u0627\u0644\u063A\u0631\u0628\u064A\u0629\u202C\u200E)", "eh", "212", 1, ["5288", "5289"]], ["Yemen (\u202B\u0627\u0644\u064A\u0645\u0646\u202C\u200E)", "ye", "967"], ["Zambia", "zm", "260"], ["Zimbabwe", "zw", "263"], ["\xC5land Islands", "ax", "358", 1, ["18"]]];
      for (var i = 0; i < allCountries.length; i++) {
        var c = allCountries[i];
        allCountries[i] = {
          name: c[0],
          iso2: c[1],
          dialCode: c[2],
          priority: c[3] || 0,
          areaCodes: c[4] || null
        };
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var intlTelInputGlobals = {
        getInstance: function getInstance(input) {
          var id2 = input.getAttribute("data-intl-tel-input-id");
          return window.intlTelInputGlobals.instances[id2];
        },
        instances: {},
        documentReady: function documentReady() {
          return document.readyState === "complete";
        }
      };
      if (typeof window === "object")
        window.intlTelInputGlobals = intlTelInputGlobals;
      var id = 0;
      var defaults = {
        allowDropdown: true,
        autoHideDialCode: true,
        autoPlaceholder: "polite",
        customContainer: "",
        customPlaceholder: null,
        dropdownContainer: null,
        excludeCountries: [],
        formatOnDisplay: true,
        geoIpLookup: null,
        hiddenInput: "",
        initialCountry: "",
        localizedCountries: null,
        nationalMode: true,
        onlyCountries: [],
        placeholderNumberType: "MOBILE",
        preferredCountries: ["us", "gb"],
        separateDialCode: false,
        utilsScript: ""
      };
      var regionlessNanpNumbers = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"];
      var forEachProp = function forEachProp2(obj, callback) {
        var keys = Object.keys(obj);
        for (var i2 = 0; i2 < keys.length; i2++) {
          callback(keys[i2], obj[keys[i2]]);
        }
      };
      var forEachInstance = function forEachInstance2(method) {
        forEachProp(window.intlTelInputGlobals.instances, function(key) {
          window.intlTelInputGlobals.instances[key][method]();
        });
      };
      var Iti = /* @__PURE__ */ function() {
        function Iti2(input, options) {
          var _this = this;
          _classCallCheck(this, Iti2);
          this.id = id++;
          this.telInput = input;
          this.activeItem = null;
          this.highlightedItem = null;
          var customOptions = options || {};
          this.options = {};
          forEachProp(defaults, function(key, value) {
            _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value;
          });
          this.hadInitialPlaceholder = Boolean(input.getAttribute("placeholder"));
        }
        _createClass(Iti2, [{
          key: "_init",
          value: function _init() {
            var _this2 = this;
            if (this.options.nationalMode)
              this.options.autoHideDialCode = false;
            if (this.options.separateDialCode) {
              this.options.autoHideDialCode = this.options.nationalMode = false;
            }
            this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (this.isMobile) {
              document.body.classList.add("iti-mobile");
              if (!this.options.dropdownContainer)
                this.options.dropdownContainer = document.body;
            }
            if (typeof Promise !== "undefined") {
              var autoCountryPromise = new Promise(function(resolve, reject) {
                _this2.resolveAutoCountryPromise = resolve;
                _this2.rejectAutoCountryPromise = reject;
              });
              var utilsScriptPromise = new Promise(function(resolve, reject) {
                _this2.resolveUtilsScriptPromise = resolve;
                _this2.rejectUtilsScriptPromise = reject;
              });
              this.promise = Promise.all([autoCountryPromise, utilsScriptPromise]);
            } else {
              this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function() {
              };
              this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function() {
              };
            }
            this.selectedCountryData = {};
            this._processCountryData();
            this._generateMarkup();
            this._setInitialState();
            this._initListeners();
            this._initRequests();
          }
        }, {
          key: "_processCountryData",
          value: function _processCountryData() {
            this._processAllCountries();
            this._processCountryCodes();
            this._processPreferredCountries();
            if (this.options.localizedCountries)
              this._translateCountriesByLocale();
            if (this.options.onlyCountries.length || this.options.localizedCountries) {
              this.countries.sort(this._countryNameSort);
            }
          }
        }, {
          key: "_addCountryCode",
          value: function _addCountryCode(iso2, countryCode, priority) {
            if (countryCode.length > this.countryCodeMaxLen) {
              this.countryCodeMaxLen = countryCode.length;
            }
            if (!this.countryCodes.hasOwnProperty(countryCode)) {
              this.countryCodes[countryCode] = [];
            }
            for (var i2 = 0; i2 < this.countryCodes[countryCode].length; i2++) {
              if (this.countryCodes[countryCode][i2] === iso2)
                return;
            }
            var index = priority !== undefined$1 ? priority : this.countryCodes[countryCode].length;
            this.countryCodes[countryCode][index] = iso2;
          }
        }, {
          key: "_processAllCountries",
          value: function _processAllCountries() {
            if (this.options.onlyCountries.length) {
              var lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {
                return country.toLowerCase();
              });
              this.countries = allCountries.filter(function(country) {
                return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;
              });
            } else if (this.options.excludeCountries.length) {
              var lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {
                return country.toLowerCase();
              });
              this.countries = allCountries.filter(function(country) {
                return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;
              });
            } else {
              this.countries = allCountries;
            }
          }
        }, {
          key: "_translateCountriesByLocale",
          value: function _translateCountriesByLocale() {
            for (var i2 = 0; i2 < this.countries.length; i2++) {
              var iso = this.countries[i2].iso2.toLowerCase();
              if (this.options.localizedCountries.hasOwnProperty(iso)) {
                this.countries[i2].name = this.options.localizedCountries[iso];
              }
            }
          }
        }, {
          key: "_countryNameSort",
          value: function _countryNameSort(a, b) {
            return a.name.localeCompare(b.name);
          }
        }, {
          key: "_processCountryCodes",
          value: function _processCountryCodes() {
            this.countryCodeMaxLen = 0;
            this.dialCodes = {};
            this.countryCodes = {};
            for (var i2 = 0; i2 < this.countries.length; i2++) {
              var c2 = this.countries[i2];
              if (!this.dialCodes[c2.dialCode])
                this.dialCodes[c2.dialCode] = true;
              this._addCountryCode(c2.iso2, c2.dialCode, c2.priority);
            }
            for (var _i = 0; _i < this.countries.length; _i++) {
              var _c = this.countries[_i];
              if (_c.areaCodes) {
                var rootCountryCode = this.countryCodes[_c.dialCode][0];
                for (var j = 0; j < _c.areaCodes.length; j++) {
                  var areaCode = _c.areaCodes[j];
                  for (var k = 1; k < areaCode.length; k++) {
                    var partialDialCode = _c.dialCode + areaCode.substr(0, k);
                    this._addCountryCode(rootCountryCode, partialDialCode);
                    this._addCountryCode(_c.iso2, partialDialCode);
                  }
                  this._addCountryCode(_c.iso2, _c.dialCode + areaCode);
                }
              }
            }
          }
        }, {
          key: "_processPreferredCountries",
          value: function _processPreferredCountries() {
            this.preferredCountries = [];
            for (var i2 = 0; i2 < this.options.preferredCountries.length; i2++) {
              var countryCode = this.options.preferredCountries[i2].toLowerCase();
              var countryData = this._getCountryData(countryCode, false, true);
              if (countryData)
                this.preferredCountries.push(countryData);
            }
          }
        }, {
          key: "_createEl",
          value: function _createEl(name, attrs, container) {
            var el = document.createElement(name);
            if (attrs)
              forEachProp(attrs, function(key, value) {
                return el.setAttribute(key, value);
              });
            if (container)
              container.appendChild(el);
            return el;
          }
        }, {
          key: "_generateMarkup",
          value: function _generateMarkup() {
            if (!this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete"))) {
              this.telInput.setAttribute("autocomplete", "off");
            }
            var parentClass = "iti";
            if (this.options.allowDropdown)
              parentClass += " iti--allow-dropdown";
            if (this.options.separateDialCode)
              parentClass += " iti--separate-dial-code";
            if (this.options.customContainer) {
              parentClass += " ";
              parentClass += this.options.customContainer;
            }
            var wrapper = this._createEl("div", {
              "class": parentClass
            });
            this.telInput.parentNode.insertBefore(wrapper, this.telInput);
            this.flagsContainer = this._createEl("div", {
              "class": "iti__flag-container"
            }, wrapper);
            wrapper.appendChild(this.telInput);
            this.selectedFlag = this._createEl("div", {
              "class": "iti__selected-flag",
              role: "combobox",
              "aria-controls": "iti-".concat(this.id, "__country-listbox"),
              "aria-owns": "iti-".concat(this.id, "__country-listbox"),
              "aria-expanded": "false"
            }, this.flagsContainer);
            this.selectedFlagInner = this._createEl("div", {
              "class": "iti__flag"
            }, this.selectedFlag);
            if (this.options.separateDialCode) {
              this.selectedDialCode = this._createEl("div", {
                "class": "iti__selected-dial-code"
              }, this.selectedFlag);
            }
            if (this.options.allowDropdown) {
              this.selectedFlag.setAttribute("tabindex", "0");
              this.dropdownArrow = this._createEl("div", {
                "class": "iti__arrow"
              }, this.selectedFlag);
              this.countryList = this._createEl("ul", {
                "class": "iti__country-list iti__hide",
                id: "iti-".concat(this.id, "__country-listbox"),
                role: "listbox",
                "aria-label": "List of countries"
              });
              if (this.preferredCountries.length) {
                this._appendListItems(this.preferredCountries, "iti__preferred", true);
                this._createEl("li", {
                  "class": "iti__divider",
                  role: "separator",
                  "aria-disabled": "true"
                }, this.countryList);
              }
              this._appendListItems(this.countries, "iti__standard");
              if (this.options.dropdownContainer) {
                this.dropdown = this._createEl("div", {
                  "class": "iti iti--container"
                });
                this.dropdown.appendChild(this.countryList);
              } else {
                this.flagsContainer.appendChild(this.countryList);
              }
            }
            if (this.options.hiddenInput) {
              var hiddenInputName = this.options.hiddenInput;
              var name = this.telInput.getAttribute("name");
              if (name) {
                var i2 = name.lastIndexOf("[");
                if (i2 !== -1)
                  hiddenInputName = "".concat(name.substr(0, i2), "[").concat(hiddenInputName, "]");
              }
              this.hiddenInput = this._createEl("input", {
                type: "hidden",
                name: hiddenInputName
              });
              wrapper.appendChild(this.hiddenInput);
            }
          }
        }, {
          key: "_appendListItems",
          value: function _appendListItems(countries, className, preferred) {
            var tmp = "";
            for (var i2 = 0; i2 < countries.length; i2++) {
              var c2 = countries[i2];
              var idSuffix = preferred ? "-preferred" : "";
              tmp += "<li class='iti__country ".concat(className, "' tabIndex='-1' id='iti-").concat(this.id, "__item-").concat(c2.iso2).concat(idSuffix, "' role='option' data-dial-code='").concat(c2.dialCode, "' data-country-code='").concat(c2.iso2, "' aria-selected='false'>");
              tmp += "<div class='iti__flag-box'><div class='iti__flag iti__".concat(c2.iso2, "'></div></div>");
              tmp += "<span class='iti__country-name'>".concat(c2.name, "</span>");
              tmp += "<span class='iti__dial-code'>+".concat(c2.dialCode, "</span>");
              tmp += "</li>";
            }
            this.countryList.insertAdjacentHTML("beforeend", tmp);
          }
        }, {
          key: "_setInitialState",
          value: function _setInitialState() {
            var attributeValue = this.telInput.getAttribute("value");
            var inputValue = this.telInput.value;
            var useAttribute = attributeValue && attributeValue.charAt(0) === "+" && (!inputValue || inputValue.charAt(0) !== "+");
            var val = useAttribute ? attributeValue : inputValue;
            var dialCode = this._getDialCode(val);
            var isRegionlessNanp = this._isRegionlessNanp(val);
            var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;
            if (dialCode && !isRegionlessNanp) {
              this._updateFlagFromNumber(val);
            } else if (initialCountry !== "auto") {
              if (initialCountry) {
                this._setFlag(initialCountry.toLowerCase());
              } else {
                if (dialCode && isRegionlessNanp) {
                  this._setFlag("us");
                } else {
                  this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;
                  if (!val) {
                    this._setFlag(this.defaultCountry);
                  }
                }
              }
              if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {
                this.telInput.value = "+".concat(this.selectedCountryData.dialCode);
              }
            }
            if (val)
              this._updateValFromNumber(val);
          }
        }, {
          key: "_initListeners",
          value: function _initListeners() {
            this._initKeyListeners();
            if (this.options.autoHideDialCode)
              this._initBlurListeners();
            if (this.options.allowDropdown)
              this._initDropdownListeners();
            if (this.hiddenInput)
              this._initHiddenInputListener();
          }
        }, {
          key: "_initHiddenInputListener",
          value: function _initHiddenInputListener() {
            var _this3 = this;
            this._handleHiddenInputSubmit = function() {
              _this3.hiddenInput.value = _this3.getNumber();
            };
            if (this.telInput.form)
              this.telInput.form.addEventListener("submit", this._handleHiddenInputSubmit);
          }
        }, {
          key: "_getClosestLabel",
          value: function _getClosestLabel() {
            var el = this.telInput;
            while (el && el.tagName !== "LABEL") {
              el = el.parentNode;
            }
            return el;
          }
        }, {
          key: "_initDropdownListeners",
          value: function _initDropdownListeners() {
            var _this4 = this;
            this._handleLabelClick = function(e) {
              if (_this4.countryList.classList.contains("iti__hide"))
                _this4.telInput.focus();
              else
                e.preventDefault();
            };
            var label = this._getClosestLabel();
            if (label)
              label.addEventListener("click", this._handleLabelClick);
            this._handleClickSelectedFlag = function() {
              if (_this4.countryList.classList.contains("iti__hide") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {
                _this4._showDropdown();
              }
            };
            this.selectedFlag.addEventListener("click", this._handleClickSelectedFlag);
            this._handleFlagsContainerKeydown = function(e) {
              var isDropdownHidden = _this4.countryList.classList.contains("iti__hide");
              if (isDropdownHidden && ["ArrowUp", "Up", "ArrowDown", "Down", " ", "Enter"].indexOf(e.key) !== -1) {
                e.preventDefault();
                e.stopPropagation();
                _this4._showDropdown();
              }
              if (e.key === "Tab")
                _this4._closeDropdown();
            };
            this.flagsContainer.addEventListener("keydown", this._handleFlagsContainerKeydown);
          }
        }, {
          key: "_initRequests",
          value: function _initRequests() {
            var _this5 = this;
            if (this.options.utilsScript && !window.intlTelInputUtils) {
              if (window.intlTelInputGlobals.documentReady()) {
                window.intlTelInputGlobals.loadUtils(this.options.utilsScript);
              } else {
                window.addEventListener("load", function() {
                  window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);
                });
              }
            } else
              this.resolveUtilsScriptPromise();
            if (this.options.initialCountry === "auto")
              this._loadAutoCountry();
            else
              this.resolveAutoCountryPromise();
          }
        }, {
          key: "_loadAutoCountry",
          value: function _loadAutoCountry() {
            if (window.intlTelInputGlobals.autoCountry) {
              this.handleAutoCountry();
            } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {
              window.intlTelInputGlobals.startedLoadingAutoCountry = true;
              if (typeof this.options.geoIpLookup === "function") {
                this.options.geoIpLookup(function(countryCode) {
                  window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();
                  setTimeout(function() {
                    return forEachInstance("handleAutoCountry");
                  });
                }, function() {
                  return forEachInstance("rejectAutoCountryPromise");
                });
              }
            }
          }
        }, {
          key: "_initKeyListeners",
          value: function _initKeyListeners() {
            var _this6 = this;
            this._handleKeyupEvent = function() {
              if (_this6._updateFlagFromNumber(_this6.telInput.value)) {
                _this6._triggerCountryChange();
              }
            };
            this.telInput.addEventListener("keyup", this._handleKeyupEvent);
            this._handleClipboardEvent = function() {
              setTimeout(_this6._handleKeyupEvent);
            };
            this.telInput.addEventListener("cut", this._handleClipboardEvent);
            this.telInput.addEventListener("paste", this._handleClipboardEvent);
          }
        }, {
          key: "_cap",
          value: function _cap(number) {
            var max = this.telInput.getAttribute("maxlength");
            return max && number.length > max ? number.substr(0, max) : number;
          }
        }, {
          key: "_initBlurListeners",
          value: function _initBlurListeners() {
            var _this7 = this;
            this._handleSubmitOrBlurEvent = function() {
              _this7._removeEmptyDialCode();
            };
            if (this.telInput.form)
              this.telInput.form.addEventListener("submit", this._handleSubmitOrBlurEvent);
            this.telInput.addEventListener("blur", this._handleSubmitOrBlurEvent);
          }
        }, {
          key: "_removeEmptyDialCode",
          value: function _removeEmptyDialCode() {
            if (this.telInput.value.charAt(0) === "+") {
              var numeric = this._getNumeric(this.telInput.value);
              if (!numeric || this.selectedCountryData.dialCode === numeric) {
                this.telInput.value = "";
              }
            }
          }
        }, {
          key: "_getNumeric",
          value: function _getNumeric(s) {
            return s.replace(/\D/g, "");
          }
        }, {
          key: "_trigger",
          value: function _trigger(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            this.telInput.dispatchEvent(e);
          }
        }, {
          key: "_showDropdown",
          value: function _showDropdown() {
            this.countryList.classList.remove("iti__hide");
            this.selectedFlag.setAttribute("aria-expanded", "true");
            this._setDropdownPosition();
            if (this.activeItem) {
              this._highlightListItem(this.activeItem, false);
              this._scrollTo(this.activeItem, true);
            }
            this._bindDropdownListeners();
            this.dropdownArrow.classList.add("iti__arrow--up");
            this._trigger("open:countrydropdown");
          }
        }, {
          key: "_toggleClass",
          value: function _toggleClass(el, className, shouldHaveClass) {
            if (shouldHaveClass && !el.classList.contains(className))
              el.classList.add(className);
            else if (!shouldHaveClass && el.classList.contains(className))
              el.classList.remove(className);
          }
        }, {
          key: "_setDropdownPosition",
          value: function _setDropdownPosition() {
            var _this8 = this;
            if (this.options.dropdownContainer) {
              this.options.dropdownContainer.appendChild(this.dropdown);
            }
            if (!this.isMobile) {
              var pos = this.telInput.getBoundingClientRect();
              var windowTop = window.pageYOffset || document.documentElement.scrollTop;
              var inputTop = pos.top + windowTop;
              var dropdownHeight = this.countryList.offsetHeight;
              var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;
              var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;
              this._toggleClass(this.countryList, "iti__country-list--dropup", !dropdownFitsBelow && dropdownFitsAbove);
              if (this.options.dropdownContainer) {
                var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;
                this.dropdown.style.top = "".concat(inputTop + extraTop, "px");
                this.dropdown.style.left = "".concat(pos.left + document.body.scrollLeft, "px");
                this._handleWindowScroll = function() {
                  return _this8._closeDropdown();
                };
                window.addEventListener("scroll", this._handleWindowScroll);
              }
            }
          }
        }, {
          key: "_getClosestListItem",
          value: function _getClosestListItem(target) {
            var el = target;
            while (el && el !== this.countryList && !el.classList.contains("iti__country")) {
              el = el.parentNode;
            }
            return el === this.countryList ? null : el;
          }
        }, {
          key: "_bindDropdownListeners",
          value: function _bindDropdownListeners() {
            var _this9 = this;
            this._handleMouseoverCountryList = function(e) {
              var listItem = _this9._getClosestListItem(e.target);
              if (listItem)
                _this9._highlightListItem(listItem, false);
            };
            this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList);
            this._handleClickCountryList = function(e) {
              var listItem = _this9._getClosestListItem(e.target);
              if (listItem)
                _this9._selectListItem(listItem);
            };
            this.countryList.addEventListener("click", this._handleClickCountryList);
            var isOpening = true;
            this._handleClickOffToClose = function() {
              if (!isOpening)
                _this9._closeDropdown();
              isOpening = false;
            };
            document.documentElement.addEventListener("click", this._handleClickOffToClose);
            var query = "";
            var queryTimer = null;
            this._handleKeydownOnDropdown = function(e) {
              e.preventDefault();
              if (e.key === "ArrowUp" || e.key === "Up" || e.key === "ArrowDown" || e.key === "Down")
                _this9._handleUpDownKey(e.key);
              else if (e.key === "Enter")
                _this9._handleEnterKey();
              else if (e.key === "Escape")
                _this9._closeDropdown();
              else if (/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(e.key)) {
                if (queryTimer)
                  clearTimeout(queryTimer);
                query += e.key.toLowerCase();
                _this9._searchForCountry(query);
                queryTimer = setTimeout(function() {
                  query = "";
                }, 1e3);
              }
            };
            document.addEventListener("keydown", this._handleKeydownOnDropdown);
          }
        }, {
          key: "_handleUpDownKey",
          value: function _handleUpDownKey(key) {
            var next = key === "ArrowUp" || key === "Up" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;
            if (next) {
              if (next.classList.contains("iti__divider")) {
                next = key === "ArrowUp" || key === "Up" ? next.previousElementSibling : next.nextElementSibling;
              }
              this._highlightListItem(next, true);
            }
          }
        }, {
          key: "_handleEnterKey",
          value: function _handleEnterKey() {
            if (this.highlightedItem)
              this._selectListItem(this.highlightedItem);
          }
        }, {
          key: "_searchForCountry",
          value: function _searchForCountry(query) {
            for (var i2 = 0; i2 < this.countries.length; i2++) {
              if (this._startsWith(this.countries[i2].name, query)) {
                var listItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(this.countries[i2].iso2));
                this._highlightListItem(listItem, false);
                this._scrollTo(listItem, true);
                break;
              }
            }
          }
        }, {
          key: "_startsWith",
          value: function _startsWith(a, b) {
            return a.substr(0, b.length).toLowerCase() === b;
          }
        }, {
          key: "_updateValFromNumber",
          value: function _updateValFromNumber(originalNumber) {
            var number = originalNumber;
            if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {
              var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== "+");
              var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;
              var format = useNational ? NATIONAL : INTERNATIONAL;
              number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);
            }
            number = this._beforeSetNumber(number);
            this.telInput.value = number;
          }
        }, {
          key: "_updateFlagFromNumber",
          value: function _updateFlagFromNumber(originalNumber) {
            var number = originalNumber;
            var selectedDialCode = this.selectedCountryData.dialCode;
            var isNanp = selectedDialCode === "1";
            if (number && this.options.nationalMode && isNanp && number.charAt(0) !== "+") {
              if (number.charAt(0) !== "1")
                number = "1".concat(number);
              number = "+".concat(number);
            }
            if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== "+") {
              number = "+".concat(selectedDialCode).concat(number);
            }
            var dialCode = this._getDialCode(number, true);
            var numeric = this._getNumeric(number);
            var countryCode = null;
            if (dialCode) {
              var countryCodes = this.countryCodes[this._getNumeric(dialCode)];
              var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;
              var isRegionlessNanpNumber = selectedDialCode === "1" && this._isRegionlessNanp(numeric);
              if (!isRegionlessNanpNumber && !alreadySelected) {
                for (var j = 0; j < countryCodes.length; j++) {
                  if (countryCodes[j]) {
                    countryCode = countryCodes[j];
                    break;
                  }
                }
              }
            } else if (number.charAt(0) === "+" && numeric.length) {
              countryCode = "";
            } else if (!number || number === "+") {
              countryCode = this.defaultCountry;
            }
            if (countryCode !== null) {
              return this._setFlag(countryCode);
            }
            return false;
          }
        }, {
          key: "_isRegionlessNanp",
          value: function _isRegionlessNanp(number) {
            var numeric = this._getNumeric(number);
            if (numeric.charAt(0) === "1") {
              var areaCode = numeric.substr(1, 3);
              return regionlessNanpNumbers.indexOf(areaCode) !== -1;
            }
            return false;
          }
        }, {
          key: "_highlightListItem",
          value: function _highlightListItem(listItem, shouldFocus) {
            var prevItem = this.highlightedItem;
            if (prevItem)
              prevItem.classList.remove("iti__highlight");
            this.highlightedItem = listItem;
            this.highlightedItem.classList.add("iti__highlight");
            if (shouldFocus)
              this.highlightedItem.focus();
          }
        }, {
          key: "_getCountryData",
          value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {
            var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
            for (var i2 = 0; i2 < countryList.length; i2++) {
              if (countryList[i2].iso2 === countryCode) {
                return countryList[i2];
              }
            }
            if (allowFail) {
              return null;
            }
            throw new Error("No country data for '".concat(countryCode, "'"));
          }
        }, {
          key: "_setFlag",
          value: function _setFlag(countryCode) {
            var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
            this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
            if (this.selectedCountryData.iso2) {
              this.defaultCountry = this.selectedCountryData.iso2;
            }
            this.selectedFlagInner.setAttribute("class", "iti__flag iti__".concat(countryCode));
            var title = countryCode ? "".concat(this.selectedCountryData.name, ": +").concat(this.selectedCountryData.dialCode) : "Unknown";
            this.selectedFlag.setAttribute("title", title);
            if (this.options.separateDialCode) {
              var dialCode = this.selectedCountryData.dialCode ? "+".concat(this.selectedCountryData.dialCode) : "";
              this.selectedDialCode.innerHTML = dialCode;
              var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();
              this.telInput.style.paddingLeft = "".concat(selectedFlagWidth + 6, "px");
            }
            this._updatePlaceholder();
            if (this.options.allowDropdown) {
              var prevItem = this.activeItem;
              if (prevItem) {
                prevItem.classList.remove("iti__active");
                prevItem.setAttribute("aria-selected", "false");
              }
              if (countryCode) {
                var nextItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode, "-preferred")) || this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode));
                nextItem.setAttribute("aria-selected", "true");
                nextItem.classList.add("iti__active");
                this.activeItem = nextItem;
                this.selectedFlag.setAttribute("aria-activedescendant", nextItem.getAttribute("id"));
              }
            }
            return prevCountry.iso2 !== countryCode;
          }
        }, {
          key: "_getHiddenSelectedFlagWidth",
          value: function _getHiddenSelectedFlagWidth() {
            var containerClone = this.telInput.parentNode.cloneNode();
            containerClone.style.visibility = "hidden";
            document.body.appendChild(containerClone);
            var flagsContainerClone = this.flagsContainer.cloneNode();
            containerClone.appendChild(flagsContainerClone);
            var selectedFlagClone = this.selectedFlag.cloneNode(true);
            flagsContainerClone.appendChild(selectedFlagClone);
            var width = selectedFlagClone.offsetWidth;
            containerClone.parentNode.removeChild(containerClone);
            return width;
          }
        }, {
          key: "_updatePlaceholder",
          value: function _updatePlaceholder() {
            var shouldSetPlaceholder = this.options.autoPlaceholder === "aggressive" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === "polite";
            if (window.intlTelInputUtils && shouldSetPlaceholder) {
              var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];
              var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : "";
              placeholder = this._beforeSetNumber(placeholder);
              if (typeof this.options.customPlaceholder === "function") {
                placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);
              }
              this.telInput.setAttribute("placeholder", placeholder);
            }
          }
        }, {
          key: "_selectListItem",
          value: function _selectListItem(listItem) {
            var flagChanged = this._setFlag(listItem.getAttribute("data-country-code"));
            this._closeDropdown();
            this._updateDialCode(listItem.getAttribute("data-dial-code"), true);
            this.telInput.focus();
            var len = this.telInput.value.length;
            this.telInput.setSelectionRange(len, len);
            if (flagChanged) {
              this._triggerCountryChange();
            }
          }
        }, {
          key: "_closeDropdown",
          value: function _closeDropdown() {
            this.countryList.classList.add("iti__hide");
            this.selectedFlag.setAttribute("aria-expanded", "false");
            this.dropdownArrow.classList.remove("iti__arrow--up");
            document.removeEventListener("keydown", this._handleKeydownOnDropdown);
            document.documentElement.removeEventListener("click", this._handleClickOffToClose);
            this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList);
            this.countryList.removeEventListener("click", this._handleClickCountryList);
            if (this.options.dropdownContainer) {
              if (!this.isMobile)
                window.removeEventListener("scroll", this._handleWindowScroll);
              if (this.dropdown.parentNode)
                this.dropdown.parentNode.removeChild(this.dropdown);
            }
            this._trigger("close:countrydropdown");
          }
        }, {
          key: "_scrollTo",
          value: function _scrollTo(element, middle) {
            var container = this.countryList;
            var windowTop = window.pageYOffset || document.documentElement.scrollTop;
            var containerHeight = container.offsetHeight;
            var containerTop = container.getBoundingClientRect().top + windowTop;
            var containerBottom = containerTop + containerHeight;
            var elementHeight = element.offsetHeight;
            var elementTop = element.getBoundingClientRect().top + windowTop;
            var elementBottom = elementTop + elementHeight;
            var newScrollTop = elementTop - containerTop + container.scrollTop;
            var middleOffset = containerHeight / 2 - elementHeight / 2;
            if (elementTop < containerTop) {
              if (middle)
                newScrollTop -= middleOffset;
              container.scrollTop = newScrollTop;
            } else if (elementBottom > containerBottom) {
              if (middle)
                newScrollTop += middleOffset;
              var heightDifference = containerHeight - elementHeight;
              container.scrollTop = newScrollTop - heightDifference;
            }
          }
        }, {
          key: "_updateDialCode",
          value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {
            var inputVal = this.telInput.value;
            var newDialCode = "+".concat(newDialCodeBare);
            var newNumber;
            if (inputVal.charAt(0) === "+") {
              var prevDialCode = this._getDialCode(inputVal);
              if (prevDialCode) {
                newNumber = inputVal.replace(prevDialCode, newDialCode);
              } else {
                newNumber = newDialCode;
              }
            } else if (this.options.nationalMode || this.options.separateDialCode) {
              return;
            } else {
              if (inputVal) {
                newNumber = newDialCode + inputVal;
              } else if (hasSelectedListItem || !this.options.autoHideDialCode) {
                newNumber = newDialCode;
              } else {
                return;
              }
            }
            this.telInput.value = newNumber;
          }
        }, {
          key: "_getDialCode",
          value: function _getDialCode(number, includeAreaCode) {
            var dialCode = "";
            if (number.charAt(0) === "+") {
              var numericChars = "";
              for (var i2 = 0; i2 < number.length; i2++) {
                var c2 = number.charAt(i2);
                if (!isNaN(parseInt(c2, 10))) {
                  numericChars += c2;
                  if (includeAreaCode) {
                    if (this.countryCodes[numericChars]) {
                      dialCode = number.substr(0, i2 + 1);
                    }
                  } else {
                    if (this.dialCodes[numericChars]) {
                      dialCode = number.substr(0, i2 + 1);
                      break;
                    }
                  }
                  if (numericChars.length === this.countryCodeMaxLen) {
                    break;
                  }
                }
              }
            }
            return dialCode;
          }
        }, {
          key: "_getFullNumber",
          value: function _getFullNumber() {
            var val = this.telInput.value.trim();
            var dialCode = this.selectedCountryData.dialCode;
            var prefix;
            var numericVal = this._getNumeric(val);
            if (this.options.separateDialCode && val.charAt(0) !== "+" && dialCode && numericVal) {
              prefix = "+".concat(dialCode);
            } else {
              prefix = "";
            }
            return prefix + val;
          }
        }, {
          key: "_beforeSetNumber",
          value: function _beforeSetNumber(originalNumber) {
            var number = originalNumber;
            if (this.options.separateDialCode) {
              var dialCode = this._getDialCode(number);
              if (dialCode) {
                dialCode = "+".concat(this.selectedCountryData.dialCode);
                var start = number[dialCode.length] === " " || number[dialCode.length] === "-" ? dialCode.length + 1 : dialCode.length;
                number = number.substr(start);
              }
            }
            return this._cap(number);
          }
        }, {
          key: "_triggerCountryChange",
          value: function _triggerCountryChange() {
            this._trigger("countrychange");
          }
        }, {
          key: "handleAutoCountry",
          value: function handleAutoCountry() {
            if (this.options.initialCountry === "auto") {
              this.defaultCountry = window.intlTelInputGlobals.autoCountry;
              if (!this.telInput.value) {
                this.setCountry(this.defaultCountry);
              }
              this.resolveAutoCountryPromise();
            }
          }
        }, {
          key: "handleUtils",
          value: function handleUtils() {
            if (window.intlTelInputUtils) {
              if (this.telInput.value) {
                this._updateValFromNumber(this.telInput.value);
              }
              this._updatePlaceholder();
            }
            this.resolveUtilsScriptPromise();
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var form = this.telInput.form;
            if (this.options.allowDropdown) {
              this._closeDropdown();
              this.selectedFlag.removeEventListener("click", this._handleClickSelectedFlag);
              this.flagsContainer.removeEventListener("keydown", this._handleFlagsContainerKeydown);
              var label = this._getClosestLabel();
              if (label)
                label.removeEventListener("click", this._handleLabelClick);
            }
            if (this.hiddenInput && form)
              form.removeEventListener("submit", this._handleHiddenInputSubmit);
            if (this.options.autoHideDialCode) {
              if (form)
                form.removeEventListener("submit", this._handleSubmitOrBlurEvent);
              this.telInput.removeEventListener("blur", this._handleSubmitOrBlurEvent);
            }
            this.telInput.removeEventListener("keyup", this._handleKeyupEvent);
            this.telInput.removeEventListener("cut", this._handleClipboardEvent);
            this.telInput.removeEventListener("paste", this._handleClipboardEvent);
            this.telInput.removeAttribute("data-intl-tel-input-id");
            var wrapper = this.telInput.parentNode;
            wrapper.parentNode.insertBefore(this.telInput, wrapper);
            wrapper.parentNode.removeChild(wrapper);
            delete window.intlTelInputGlobals.instances[this.id];
          }
        }, {
          key: "getExtension",
          value: function getExtension() {
            if (window.intlTelInputUtils) {
              return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);
            }
            return "";
          }
        }, {
          key: "getNumber",
          value: function getNumber(format) {
            if (window.intlTelInputUtils) {
              var iso2 = this.selectedCountryData.iso2;
              return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);
            }
            return "";
          }
        }, {
          key: "getNumberType",
          value: function getNumberType() {
            if (window.intlTelInputUtils) {
              return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);
            }
            return -99;
          }
        }, {
          key: "getSelectedCountryData",
          value: function getSelectedCountryData() {
            return this.selectedCountryData;
          }
        }, {
          key: "getValidationError",
          value: function getValidationError() {
            if (window.intlTelInputUtils) {
              var iso2 = this.selectedCountryData.iso2;
              return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);
            }
            return -99;
          }
        }, {
          key: "isValidNumber",
          value: function isValidNumber() {
            var val = this._getFullNumber().trim();
            var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
            return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
          }
        }, {
          key: "setCountry",
          value: function setCountry(originalCountryCode) {
            var countryCode = originalCountryCode.toLowerCase();
            if (!this.selectedFlagInner.classList.contains("iti__".concat(countryCode))) {
              this._setFlag(countryCode);
              this._updateDialCode(this.selectedCountryData.dialCode, false);
              this._triggerCountryChange();
            }
          }
        }, {
          key: "setNumber",
          value: function setNumber(number) {
            var flagChanged = this._updateFlagFromNumber(number);
            this._updateValFromNumber(number);
            if (flagChanged) {
              this._triggerCountryChange();
            }
          }
        }, {
          key: "setPlaceholderNumberType",
          value: function setPlaceholderNumberType(type) {
            this.options.placeholderNumberType = type;
            this._updatePlaceholder();
          }
        }]);
        return Iti2;
      }();
      intlTelInputGlobals.getCountryData = function() {
        return allCountries;
      };
      var injectScript = function injectScript2(path, handleSuccess, handleFailure) {
        var script = document.createElement("script");
        script.onload = function() {
          forEachInstance("handleUtils");
          if (handleSuccess)
            handleSuccess();
        };
        script.onerror = function() {
          forEachInstance("rejectUtilsScriptPromise");
          if (handleFailure)
            handleFailure();
        };
        script.className = "iti-load-utils";
        script.async = true;
        script.src = path;
        document.body.appendChild(script);
      };
      intlTelInputGlobals.loadUtils = function(path) {
        if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {
          window.intlTelInputGlobals.startedLoadingUtilsScript = true;
          if (typeof Promise !== "undefined") {
            return new Promise(function(resolve, reject) {
              return injectScript(path, resolve, reject);
            });
          }
          injectScript(path);
        }
        return null;
      };
      intlTelInputGlobals.defaults = defaults;
      intlTelInputGlobals.version = "17.0.19";
      return function(input, options) {
        var iti = new Iti(input, options);
        iti._init();
        input.setAttribute("data-intl-tel-input-id", iti.id);
        window.intlTelInputGlobals.instances[iti.id] = iti;
        return iti;
      };
    }();
  });
})(intlTelInput$1);
var intlTelInput = intlTelInput$1.exports;
var gridstack = {};
var gridstackEngine = {};
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
utils.Utils = utils.obsoleteAttr = utils.obsoleteOptsDel = utils.obsoleteOpts = utils.obsolete = void 0;
function obsolete(self, f, oldName, newName, rev) {
  let wrapper = (...args) => {
    console.warn("gridstack.js: Function `" + oldName + "` is deprecated in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
    return f.apply(self, args);
  };
  wrapper.prototype = f.prototype;
  return wrapper;
}
utils.obsolete = obsolete;
function obsoleteOpts(opts, oldName, newName, rev) {
  if (opts[oldName] !== void 0) {
    opts[newName] = opts[oldName];
    console.warn("gridstack.js: Option `" + oldName + "` is deprecated in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
  }
}
utils.obsoleteOpts = obsoleteOpts;
function obsoleteOptsDel(opts, oldName, rev, info) {
  if (opts[oldName] !== void 0) {
    console.warn("gridstack.js: Option `" + oldName + "` is deprecated in " + rev + info);
  }
}
utils.obsoleteOptsDel = obsoleteOptsDel;
function obsoleteAttr(el, oldName, newName, rev) {
  let oldAttr = el.getAttribute(oldName);
  if (oldAttr !== null) {
    el.setAttribute(newName, oldAttr);
    console.warn("gridstack.js: attribute `" + oldName + "`=" + oldAttr + " is deprecated on this object in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
  }
}
utils.obsoleteAttr = obsoleteAttr;
class Utils {
  static getElements(els) {
    if (typeof els === "string") {
      let list = document.querySelectorAll(els);
      if (!list.length && els[0] !== "." && els[0] !== "#") {
        list = document.querySelectorAll("." + els);
        if (!list.length) {
          list = document.querySelectorAll("#" + els);
        }
      }
      return Array.from(list);
    }
    return [els];
  }
  static getElement(els) {
    if (typeof els === "string") {
      if (!els.length)
        return null;
      if (els[0] === "#") {
        return document.getElementById(els.substring(1));
      }
      if (els[0] === "." || els[0] === "[") {
        return document.querySelector(els);
      }
      if (!isNaN(+els[0])) {
        return document.getElementById(els);
      }
      let el = document.querySelector(els);
      if (!el) {
        el = document.getElementById(els);
      }
      if (!el) {
        el = document.querySelector("." + els);
      }
      return el;
    }
    return els;
  }
  static isIntercepted(a, b) {
    return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);
  }
  static isTouching(a, b) {
    return Utils.isIntercepted(a, { x: b.x - 0.5, y: b.y - 0.5, w: b.w + 1, h: b.h + 1 });
  }
  static sort(nodes, dir, column) {
    column = column || nodes.reduce((col, n) => Math.max(n.x + n.w, col), 0) || 12;
    if (dir === -1)
      return nodes.sort((a, b) => b.x + b.y * column - (a.x + a.y * column));
    else
      return nodes.sort((b, a) => b.x + b.y * column - (a.x + a.y * column));
  }
  static createStylesheet(id, parent) {
    let style = document.createElement("style");
    style.setAttribute("type", "text/css");
    style.setAttribute("gs-style-id", id);
    if (style.styleSheet) {
      style.styleSheet.cssText = "";
    } else {
      style.appendChild(document.createTextNode(""));
    }
    if (!parent) {
      parent = document.getElementsByTagName("head")[0];
      parent.appendChild(style);
    } else {
      parent.insertBefore(style, parent.firstChild);
    }
    return style.sheet;
  }
  static removeStylesheet(id) {
    let el = document.querySelector("STYLE[gs-style-id=" + id + "]");
    if (el && el.parentNode)
      el.remove();
  }
  static addCSSRule(sheet, selector, rules) {
    if (typeof sheet.addRule === "function") {
      sheet.addRule(selector, rules);
    } else if (typeof sheet.insertRule === "function") {
      sheet.insertRule(`${selector}{${rules}}`);
    }
  }
  static toBool(v) {
    if (typeof v === "boolean") {
      return v;
    }
    if (typeof v === "string") {
      v = v.toLowerCase();
      return !(v === "" || v === "no" || v === "false" || v === "0");
    }
    return Boolean(v);
  }
  static toNumber(value) {
    return value === null || value.length === 0 ? void 0 : Number(value);
  }
  static parseHeight(val) {
    let h;
    let unit = "px";
    if (typeof val === "string") {
      let match = val.match(/^(-[0-9]+\.[0-9]+|[0-9]*\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);
      if (!match) {
        throw new Error("Invalid height");
      }
      unit = match[2] || "px";
      h = parseFloat(match[1]);
    } else {
      h = val;
    }
    return { h, unit };
  }
  static defaults(target, ...sources) {
    sources.forEach((source) => {
      for (const key in source) {
        if (!source.hasOwnProperty(key))
          return;
        if (target[key] === null || target[key] === void 0) {
          target[key] = source[key];
        } else if (typeof source[key] === "object" && typeof target[key] === "object") {
          this.defaults(target[key], source[key]);
        }
      }
    });
    return target;
  }
  static same(a, b) {
    if (typeof a !== "object")
      return a == b;
    if (typeof a !== typeof b)
      return false;
    if (Object.keys(a).length !== Object.keys(b).length)
      return false;
    for (const key in a) {
      if (a[key] !== b[key])
        return false;
    }
    return true;
  }
  static copyPos(a, b, minMax = false) {
    a.x = b.x;
    a.y = b.y;
    a.w = b.w;
    a.h = b.h;
    if (!minMax)
      return a;
    if (b.minW)
      a.minW = b.minW;
    if (b.minH)
      a.minH = b.minH;
    if (b.maxW)
      a.maxW = b.maxW;
    if (b.maxH)
      a.maxH = b.maxH;
    return a;
  }
  static samePos(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h;
  }
  static removeInternalAndSame(a, b) {
    if (typeof a !== "object" || typeof b !== "object")
      return;
    for (let key in a) {
      let val = a[key];
      if (key[0] === "_" || val === b[key]) {
        delete a[key];
      } else if (val && typeof val === "object" && b[key] !== void 0) {
        for (let i in val) {
          if (val[i] === b[key][i] || i[0] === "_") {
            delete val[i];
          }
        }
        if (!Object.keys(val).length) {
          delete a[key];
        }
      }
    }
  }
  static closestByClass(el, name) {
    while (el) {
      if (el.classList.contains(name))
        return el;
      el = el.parentElement;
    }
    return null;
  }
  static throttle(func, delay) {
    let isWaiting = false;
    return (...args) => {
      if (!isWaiting) {
        isWaiting = true;
        setTimeout(() => {
          func(...args);
          isWaiting = false;
        }, delay);
      }
    };
  }
  static removePositioningStyles(el) {
    let style = el.style;
    if (style.position) {
      style.removeProperty("position");
    }
    if (style.left) {
      style.removeProperty("left");
    }
    if (style.top) {
      style.removeProperty("top");
    }
    if (style.width) {
      style.removeProperty("width");
    }
    if (style.height) {
      style.removeProperty("height");
    }
  }
  static getScrollElement(el) {
    if (!el)
      return document.scrollingElement || document.documentElement;
    const style = getComputedStyle(el);
    const overflowRegex = /(auto|scroll)/;
    if (overflowRegex.test(style.overflow + style.overflowY)) {
      return el;
    } else {
      return this.getScrollElement(el.parentElement);
    }
  }
  static updateScrollPosition(el, position, distance) {
    let rect = el.getBoundingClientRect();
    let innerHeightOrClientHeight = window.innerHeight || document.documentElement.clientHeight;
    if (rect.top < 0 || rect.bottom > innerHeightOrClientHeight) {
      let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;
      let offsetDiffUp = rect.top;
      let scrollEl = this.getScrollElement(el);
      if (scrollEl !== null) {
        let prevScroll = scrollEl.scrollTop;
        if (rect.top < 0 && distance < 0) {
          if (el.offsetHeight > innerHeightOrClientHeight) {
            scrollEl.scrollTop += distance;
          } else {
            scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;
          }
        } else if (distance > 0) {
          if (el.offsetHeight > innerHeightOrClientHeight) {
            scrollEl.scrollTop += distance;
          } else {
            scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;
          }
        }
        position.top += scrollEl.scrollTop - prevScroll;
      }
    }
  }
  static updateScrollResize(event, el, distance) {
    const scrollEl = this.getScrollElement(el);
    const height = scrollEl.clientHeight;
    const offsetTop = scrollEl === this.getScrollElement() ? 0 : scrollEl.getBoundingClientRect().top;
    const pointerPosY = event.clientY - offsetTop;
    const top = pointerPosY < distance;
    const bottom = pointerPosY > height - distance;
    if (top) {
      scrollEl.scrollBy({ behavior: "smooth", top: pointerPosY - distance });
    } else if (bottom) {
      scrollEl.scrollBy({ behavior: "smooth", top: distance - (height - pointerPosY) });
    }
  }
  static clone(obj) {
    if (obj === null || obj === void 0 || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Array) {
      return [...obj];
    }
    return Object.assign({}, obj);
  }
  static cloneDeep(obj) {
    const ret = Utils.clone(obj);
    for (const key in ret) {
      if (ret.hasOwnProperty(key) && typeof ret[key] === "object" && key.substring(0, 2) !== "__" && !skipFields.find((k) => k === key)) {
        ret[key] = Utils.cloneDeep(obj[key]);
      }
    }
    return ret;
  }
}
utils.Utils = Utils;
const skipFields = ["_isNested", "el", "grid", "subGrid", "engine"];
Object.defineProperty(gridstackEngine, "__esModule", { value: true });
gridstackEngine.GridStackEngine = void 0;
const utils_1 = utils;
class GridStackEngine {
  constructor(opts = {}) {
    this.addedNodes = [];
    this.removedNodes = [];
    this.column = opts.column || 12;
    this.onChange = opts.onChange;
    this._float = opts.float;
    this.maxRow = opts.maxRow;
    this.nodes = opts.nodes || [];
  }
  batchUpdate() {
    if (this.batchMode)
      return this;
    this.batchMode = true;
    this._prevFloat = this._float;
    this._float = true;
    this.saveInitial();
    return this;
  }
  commit() {
    if (!this.batchMode)
      return this;
    this.batchMode = false;
    this._float = this._prevFloat;
    delete this._prevFloat;
    return this._packNodes()._notify();
  }
  _useEntireRowArea(node, nn) {
    return !this.float && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);
  }
  _fixCollisions(node, nn = node, collide, opt = {}) {
    this._sortNodes(-1);
    collide = collide || this.collide(node, nn);
    if (!collide)
      return false;
    if (node._moving && !opt.nested && !this.float) {
      if (this.swap(node, collide))
        return true;
    }
    let area = nn;
    if (this._useEntireRowArea(node, nn)) {
      area = { x: 0, w: this.column, y: nn.y, h: nn.h };
      collide = this.collide(node, area, opt.skip);
    }
    let didMove = false;
    let newOpt = { nested: true, pack: false };
    while (collide = collide || this.collide(node, area, opt.skip)) {
      let moved;
      if (collide.locked || node._moving && !node._skipDown && nn.y > node.y && !this.float && (!this.collide(collide, Object.assign(Object.assign({}, collide), { y: node.y }), node) || !this.collide(collide, Object.assign(Object.assign({}, collide), { y: nn.y - collide.h }), node))) {
        node._skipDown = node._skipDown || nn.y > node.y;
        moved = this.moveNode(node, Object.assign(Object.assign(Object.assign({}, nn), { y: collide.y + collide.h }), newOpt));
        if (collide.locked && moved) {
          utils_1.Utils.copyPos(nn, node);
        } else if (!collide.locked && moved && opt.pack) {
          this._packNodes();
          nn.y = collide.y + collide.h;
          utils_1.Utils.copyPos(node, nn);
        }
        didMove = didMove || moved;
      } else {
        moved = this.moveNode(collide, Object.assign(Object.assign(Object.assign({}, collide), { y: nn.y + nn.h, skip: node }), newOpt));
      }
      if (!moved) {
        return didMove;
      }
      collide = void 0;
    }
    return didMove;
  }
  collide(skip, area = skip, skip2) {
    return this.nodes.find((n) => n !== skip && n !== skip2 && utils_1.Utils.isIntercepted(n, area));
  }
  collideAll(skip, area = skip, skip2) {
    return this.nodes.filter((n) => n !== skip && n !== skip2 && utils_1.Utils.isIntercepted(n, area));
  }
  collideCoverage(node, o, collides) {
    if (!o.rect || !node._rect)
      return;
    let r0 = node._rect;
    let r = Object.assign({}, o.rect);
    if (r.y > r0.y) {
      r.h += r.y - r0.y;
      r.y = r0.y;
    } else {
      r.h += r0.y - r.y;
    }
    if (r.x > r0.x) {
      r.w += r.x - r0.x;
      r.x = r0.x;
    } else {
      r.w += r0.x - r.x;
    }
    let collide;
    collides.forEach((n) => {
      if (n.locked || !n._rect)
        return;
      let r2 = n._rect;
      let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE, overMax = 0.5;
      if (r0.y < r2.y) {
        yOver = (r.y + r.h - r2.y) / r2.h;
      } else if (r0.y + r0.h > r2.y + r2.h) {
        yOver = (r2.y + r2.h - r.y) / r2.h;
      }
      if (r0.x < r2.x) {
        xOver = (r.x + r.w - r2.x) / r2.w;
      } else if (r0.x + r0.w > r2.x + r2.w) {
        xOver = (r2.x + r2.w - r.x) / r2.w;
      }
      let over = Math.min(xOver, yOver);
      if (over > overMax) {
        overMax = over;
        collide = n;
      }
    });
    return collide;
  }
  cacheRects(w, h, top, right, bottom, left) {
    this.nodes.forEach((n) => n._rect = {
      y: n.y * h + top,
      x: n.x * w + left,
      w: n.w * w - left - right,
      h: n.h * h - top - bottom
    });
    return this;
  }
  swap(a, b) {
    if (!b || b.locked || !a || a.locked)
      return false;
    function _doSwap() {
      let x = b.x, y = b.y;
      b.x = a.x;
      b.y = a.y;
      if (a.h != b.h) {
        a.x = x;
        a.y = b.y + b.h;
      } else if (a.w != b.w) {
        a.x = b.x + b.w;
        a.y = y;
      } else {
        a.x = x;
        a.y = y;
      }
      a._dirty = b._dirty = true;
      return true;
    }
    let touching;
    if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = utils_1.Utils.isTouching(a, b)))
      return _doSwap();
    if (touching === false)
      return;
    if (a.w === b.w && a.x === b.x && (touching || (touching = utils_1.Utils.isTouching(a, b)))) {
      if (b.y < a.y) {
        let t = a;
        a = b;
        b = t;
      }
      return _doSwap();
    }
    if (touching === false)
      return;
    if (a.h === b.h && a.y === b.y && (touching || (touching = utils_1.Utils.isTouching(a, b)))) {
      if (b.x < a.x) {
        let t = a;
        a = b;
        b = t;
      }
      return _doSwap();
    }
    return false;
  }
  isAreaEmpty(x, y, w, h) {
    let nn = { x: x || 0, y: y || 0, w: w || 1, h: h || 1 };
    return !this.collide(nn);
  }
  compact() {
    if (this.nodes.length === 0)
      return this;
    this.batchUpdate()._sortNodes();
    let copyNodes = this.nodes;
    this.nodes = [];
    copyNodes.forEach((node) => {
      if (!node.locked) {
        node.autoPosition = true;
      }
      this.addNode(node, false);
      node._dirty = true;
    });
    return this.commit();
  }
  set float(val) {
    if (this._float === val)
      return;
    this._float = val || false;
    if (!val) {
      this._packNodes()._notify();
    }
  }
  get float() {
    return this._float || false;
  }
  _sortNodes(dir) {
    this.nodes = utils_1.Utils.sort(this.nodes, dir, this.column);
    return this;
  }
  _packNodes() {
    if (this.batchMode) {
      return this;
    }
    this._sortNodes();
    if (this.float) {
      this.nodes.forEach((n) => {
        if (n._updating || n._orig === void 0 || n.y === n._orig.y)
          return;
        let newY = n.y;
        while (newY > n._orig.y) {
          --newY;
          let collide = this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
          if (!collide) {
            n._dirty = true;
            n.y = newY;
          }
        }
      });
    } else {
      this.nodes.forEach((n, i) => {
        if (n.locked)
          return;
        while (n.y > 0) {
          let newY = i === 0 ? 0 : n.y - 1;
          let canBeMoved = i === 0 || !this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
          if (!canBeMoved)
            break;
          n._dirty = n.y !== newY;
          n.y = newY;
        }
      });
    }
    return this;
  }
  prepareNode(node, resizing) {
    node = node || {};
    node._id = node._id || GridStackEngine._idSeq++;
    if (node.x === void 0 || node.y === void 0 || node.x === null || node.y === null) {
      node.autoPosition = true;
    }
    let defaults = { x: 0, y: 0, w: 1, h: 1 };
    utils_1.Utils.defaults(node, defaults);
    if (!node.autoPosition) {
      delete node.autoPosition;
    }
    if (!node.noResize) {
      delete node.noResize;
    }
    if (!node.noMove) {
      delete node.noMove;
    }
    if (typeof node.x == "string") {
      node.x = Number(node.x);
    }
    if (typeof node.y == "string") {
      node.y = Number(node.y);
    }
    if (typeof node.w == "string") {
      node.w = Number(node.w);
    }
    if (typeof node.h == "string") {
      node.h = Number(node.h);
    }
    if (isNaN(node.x)) {
      node.x = defaults.x;
      node.autoPosition = true;
    }
    if (isNaN(node.y)) {
      node.y = defaults.y;
      node.autoPosition = true;
    }
    if (isNaN(node.w)) {
      node.w = defaults.w;
    }
    if (isNaN(node.h)) {
      node.h = defaults.h;
    }
    return this.nodeBoundFix(node, resizing);
  }
  nodeBoundFix(node, resizing) {
    let before = node._orig || utils_1.Utils.copyPos({}, node);
    if (node.maxW) {
      node.w = Math.min(node.w, node.maxW);
    }
    if (node.maxH) {
      node.h = Math.min(node.h, node.maxH);
    }
    if (node.minW && node.minW <= this.column) {
      node.w = Math.max(node.w, node.minW);
    }
    if (node.minH) {
      node.h = Math.max(node.h, node.minH);
    }
    if (node.w > this.column) {
      if (this.column < 12 && !this._inColumnResize) {
        node.w = Math.min(12, node.w);
        this.cacheOneLayout(node, 12);
      }
      node.w = this.column;
    } else if (node.w < 1) {
      node.w = 1;
    }
    if (this.maxRow && node.h > this.maxRow) {
      node.h = this.maxRow;
    } else if (node.h < 1) {
      node.h = 1;
    }
    if (node.x < 0) {
      node.x = 0;
    }
    if (node.y < 0) {
      node.y = 0;
    }
    if (node.x + node.w > this.column) {
      if (resizing) {
        node.w = this.column - node.x;
      } else {
        node.x = this.column - node.w;
      }
    }
    if (this.maxRow && node.y + node.h > this.maxRow) {
      if (resizing) {
        node.h = this.maxRow - node.y;
      } else {
        node.y = this.maxRow - node.h;
      }
    }
    if (!utils_1.Utils.samePos(node, before)) {
      node._dirty = true;
    }
    return node;
  }
  getDirtyNodes(verify) {
    if (verify) {
      return this.nodes.filter((n) => n._dirty && !utils_1.Utils.samePos(n, n._orig));
    }
    return this.nodes.filter((n) => n._dirty);
  }
  _notify(nodes, removeDOM = true) {
    if (this.batchMode)
      return this;
    nodes = nodes === void 0 ? [] : Array.isArray(nodes) ? nodes : [nodes];
    let dirtyNodes = nodes.concat(this.getDirtyNodes());
    this.onChange && this.onChange(dirtyNodes, removeDOM);
    return this;
  }
  cleanNodes() {
    if (this.batchMode)
      return this;
    this.nodes.forEach((n) => {
      delete n._dirty;
      delete n._lastTried;
    });
    return this;
  }
  saveInitial() {
    this.nodes.forEach((n) => {
      n._orig = utils_1.Utils.copyPos({}, n);
      delete n._dirty;
    });
    this._hasLocked = this.nodes.some((n) => n.locked);
    return this;
  }
  restoreInitial() {
    this.nodes.forEach((n) => {
      if (utils_1.Utils.samePos(n, n._orig))
        return;
      utils_1.Utils.copyPos(n, n._orig);
      n._dirty = true;
    });
    this._notify();
    return this;
  }
  addNode(node, triggerAddEvent = false) {
    let dup = this.nodes.find((n) => n._id === node._id);
    if (dup)
      return dup;
    node = this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);
    delete node._temporaryRemoved;
    delete node._removeDOM;
    if (node.autoPosition) {
      this._sortNodes();
      for (let i = 0; ; ++i) {
        let x = i % this.column;
        let y = Math.floor(i / this.column);
        if (x + node.w > this.column) {
          continue;
        }
        let box = { x, y, w: node.w, h: node.h };
        if (!this.nodes.find((n) => utils_1.Utils.isIntercepted(box, n))) {
          node.x = x;
          node.y = y;
          delete node.autoPosition;
          break;
        }
      }
    }
    this.nodes.push(node);
    if (triggerAddEvent) {
      this.addedNodes.push(node);
    }
    this._fixCollisions(node);
    if (!this.batchMode) {
      this._packNodes()._notify();
    }
    return node;
  }
  removeNode(node, removeDOM = true, triggerEvent = false) {
    if (!this.nodes.find((n) => n === node)) {
      return this;
    }
    if (triggerEvent) {
      this.removedNodes.push(node);
    }
    if (removeDOM)
      node._removeDOM = true;
    this.nodes = this.nodes.filter((n) => n !== node);
    return this._packNodes()._notify(node);
  }
  removeAll(removeDOM = true) {
    delete this._layouts;
    if (this.nodes.length === 0)
      return this;
    removeDOM && this.nodes.forEach((n) => n._removeDOM = true);
    this.removedNodes = this.nodes;
    this.nodes = [];
    return this._notify(this.removedNodes);
  }
  moveNodeCheck(node, o) {
    if (!this.changedPosConstrain(node, o))
      return false;
    o.pack = true;
    if (!this.maxRow) {
      return this.moveNode(node, o);
    }
    let clonedNode;
    let clone = new GridStackEngine({
      column: this.column,
      float: this.float,
      nodes: this.nodes.map((n) => {
        if (n === node) {
          clonedNode = Object.assign({}, n);
          return clonedNode;
        }
        return Object.assign({}, n);
      })
    });
    if (!clonedNode)
      return false;
    let canMove = clone.moveNode(clonedNode, o);
    if (this.maxRow && canMove) {
      canMove = clone.getRow() <= this.maxRow;
      if (!canMove && !o.resizing) {
        let collide = this.collide(node, o);
        if (collide && this.swap(node, collide)) {
          this._notify();
          return true;
        }
      }
    }
    if (!canMove)
      return false;
    clone.nodes.filter((n) => n._dirty).forEach((c) => {
      let n = this.nodes.find((a) => a._id === c._id);
      if (!n)
        return;
      utils_1.Utils.copyPos(n, c);
      n._dirty = true;
    });
    this._notify();
    return true;
  }
  willItFit(node) {
    delete node._willFitPos;
    if (!this.maxRow)
      return true;
    let clone = new GridStackEngine({
      column: this.column,
      float: this.float,
      nodes: this.nodes.map((n2) => {
        return Object.assign({}, n2);
      })
    });
    let n = Object.assign({}, node);
    this.cleanupNode(n);
    delete n.el;
    delete n._id;
    delete n.content;
    delete n.grid;
    clone.addNode(n);
    if (clone.getRow() <= this.maxRow) {
      node._willFitPos = utils_1.Utils.copyPos({}, n);
      return true;
    }
    return false;
  }
  changedPosConstrain(node, p) {
    p.w = p.w || node.w;
    p.h = p.h || node.h;
    if (node.x !== p.x || node.y !== p.y)
      return true;
    if (node.maxW) {
      p.w = Math.min(p.w, node.maxW);
    }
    if (node.maxH) {
      p.h = Math.min(p.h, node.maxH);
    }
    if (node.minW) {
      p.w = Math.max(p.w, node.minW);
    }
    if (node.minH) {
      p.h = Math.max(p.h, node.minH);
    }
    return node.w !== p.w || node.h !== p.h;
  }
  moveNode(node, o) {
    if (!node || !o)
      return false;
    if (o.pack === void 0)
      o.pack = true;
    if (typeof o.x !== "number") {
      o.x = node.x;
    }
    if (typeof o.y !== "number") {
      o.y = node.y;
    }
    if (typeof o.w !== "number") {
      o.w = node.w;
    }
    if (typeof o.h !== "number") {
      o.h = node.h;
    }
    let resizing = node.w !== o.w || node.h !== o.h;
    let nn = utils_1.Utils.copyPos({}, node, true);
    utils_1.Utils.copyPos(nn, o);
    nn = this.nodeBoundFix(nn, resizing);
    utils_1.Utils.copyPos(o, nn);
    if (utils_1.Utils.samePos(node, o))
      return false;
    let prevPos = utils_1.Utils.copyPos({}, node);
    let area = nn;
    let collides = this.collideAll(node, area, o.skip);
    let needToMove = true;
    if (collides.length) {
      let collide = node._moving && !o.nested ? this.collideCoverage(node, o, collides) : collides[0];
      if (collide) {
        needToMove = !this._fixCollisions(node, nn, collide, o);
      } else {
        needToMove = false;
      }
    }
    if (needToMove) {
      node._dirty = true;
      utils_1.Utils.copyPos(node, nn);
    }
    if (o.pack) {
      this._packNodes()._notify();
    }
    return !utils_1.Utils.samePos(node, prevPos);
  }
  getRow() {
    return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);
  }
  beginUpdate(node) {
    if (!node._updating) {
      node._updating = true;
      delete node._skipDown;
      if (!this.batchMode)
        this.saveInitial();
    }
    return this;
  }
  endUpdate() {
    let n = this.nodes.find((n2) => n2._updating);
    if (n) {
      delete n._updating;
      delete n._skipDown;
    }
    return this;
  }
  save(saveElement = true) {
    var _a;
    let len = (_a = this._layouts) === null || _a === void 0 ? void 0 : _a.length;
    let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;
    let list = [];
    this._sortNodes();
    this.nodes.forEach((n) => {
      let wl = layout === null || layout === void 0 ? void 0 : layout.find((l) => l._id === n._id);
      let w = Object.assign({}, n);
      if (wl) {
        w.x = wl.x;
        w.y = wl.y;
        w.w = wl.w;
      }
      for (let key in w) {
        if (key[0] === "_" || w[key] === null || w[key] === void 0)
          delete w[key];
      }
      delete w.grid;
      if (!saveElement)
        delete w.el;
      if (!w.autoPosition)
        delete w.autoPosition;
      if (!w.noResize)
        delete w.noResize;
      if (!w.noMove)
        delete w.noMove;
      if (!w.locked)
        delete w.locked;
      list.push(w);
    });
    return list;
  }
  layoutsNodesChange(nodes) {
    if (!this._layouts || this._inColumnResize)
      return this;
    this._layouts.forEach((layout, column) => {
      if (!layout || column === this.column)
        return this;
      if (column < this.column) {
        this._layouts[column] = void 0;
      } else {
        let ratio = column / this.column;
        nodes.forEach((node) => {
          if (!node._orig)
            return;
          let n = layout.find((l) => l._id === node._id);
          if (!n)
            return;
          if (node.y !== node._orig.y) {
            n.y += node.y - node._orig.y;
          }
          if (node.x !== node._orig.x) {
            n.x = Math.round(node.x * ratio);
          }
          if (node.w !== node._orig.w) {
            n.w = Math.round(node.w * ratio);
          }
        });
      }
    });
    return this;
  }
  updateNodeWidths(prevColumn, column, nodes, layout = "moveScale") {
    var _a;
    if (!this.nodes.length || !column || prevColumn === column)
      return this;
    this.cacheLayout(this.nodes, prevColumn);
    this.batchUpdate();
    let newNodes = [];
    let domOrder = false;
    if (column === 1 && (nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
      domOrder = true;
      let top = 0;
      nodes.forEach((n) => {
        n.x = 0;
        n.w = 1;
        n.y = Math.max(n.y, top);
        top = n.y + n.h;
      });
      newNodes = nodes;
      nodes = [];
    } else {
      nodes = utils_1.Utils.sort(this.nodes, -1, prevColumn);
    }
    let cacheNodes = [];
    if (column > prevColumn) {
      cacheNodes = this._layouts[column] || [];
      let lastIndex = this._layouts.length - 1;
      if (!cacheNodes.length && prevColumn !== lastIndex && ((_a = this._layouts[lastIndex]) === null || _a === void 0 ? void 0 : _a.length)) {
        prevColumn = lastIndex;
        this._layouts[lastIndex].forEach((cacheNode) => {
          let n = nodes.find((n2) => n2._id === cacheNode._id);
          if (n) {
            n.x = cacheNode.x;
            n.y = cacheNode.y;
            n.w = cacheNode.w;
          }
        });
      }
    }
    cacheNodes.forEach((cacheNode) => {
      let j = nodes.findIndex((n) => n._id === cacheNode._id);
      if (j !== -1) {
        nodes[j].x = cacheNode.x;
        nodes[j].y = cacheNode.y;
        nodes[j].w = cacheNode.w;
        newNodes.push(nodes[j]);
        nodes.splice(j, 1);
      }
    });
    if (nodes.length) {
      if (typeof layout === "function") {
        layout(column, prevColumn, newNodes, nodes);
      } else if (!domOrder) {
        let ratio = column / prevColumn;
        let move = layout === "move" || layout === "moveScale";
        let scale = layout === "scale" || layout === "moveScale";
        nodes.forEach((node) => {
          node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);
          node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);
          newNodes.push(node);
        });
        nodes = [];
      }
    }
    newNodes = utils_1.Utils.sort(newNodes, -1, column);
    this._inColumnResize = true;
    this.nodes = [];
    newNodes.forEach((node) => {
      this.addNode(node, false);
      delete node._orig;
    });
    this.commit();
    delete this._inColumnResize;
    return this;
  }
  cacheLayout(nodes, column, clear = false) {
    let copy = [];
    nodes.forEach((n, i) => {
      n._id = n._id || GridStackEngine._idSeq++;
      copy[i] = { x: n.x, y: n.y, w: n.w, _id: n._id };
    });
    this._layouts = clear ? [] : this._layouts || [];
    this._layouts[column] = copy;
    return this;
  }
  cacheOneLayout(n, column) {
    n._id = n._id || GridStackEngine._idSeq++;
    let layout = { x: n.x, y: n.y, w: n.w, _id: n._id };
    this._layouts = this._layouts || [];
    this._layouts[column] = this._layouts[column] || [];
    let index = this._layouts[column].findIndex((l) => l._id === n._id);
    index === -1 ? this._layouts[column].push(layout) : this._layouts[column][index] = layout;
    return this;
  }
  cleanupNode(node) {
    for (let prop in node) {
      if (prop[0] === "_" && prop !== "_id")
        delete node[prop];
    }
    return this;
  }
}
gridstackEngine.GridStackEngine = GridStackEngine;
GridStackEngine._idSeq = 1;
var gridstackDdi = {};
Object.defineProperty(gridstackDdi, "__esModule", { value: true });
gridstackDdi.GridStackDDI = void 0;
class GridStackDDI {
  static registerPlugin(pluginClass) {
    GridStackDDI.ddi = new pluginClass();
    return GridStackDDI.ddi;
  }
  static get() {
    return GridStackDDI.ddi || GridStackDDI.registerPlugin(GridStackDDI);
  }
  remove(el) {
    return this;
  }
}
gridstackDdi.GridStackDDI = GridStackDDI;
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !exports2.hasOwnProperty(p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridStack = void 0;
  /*!
   * GridStack 5.0
   * https://gridstackjs.com/
   *
   * Copyright (c) 2021 Alain Dumesny
   * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE
   */
  const gridstack_engine_1 = gridstackEngine;
  const utils_12 = utils;
  const gridstack_ddi_1 = gridstackDdi;
  __exportStar(types, exports);
  __exportStar(utils, exports);
  __exportStar(gridstackEngine, exports);
  __exportStar(gridstackDdi, exports);
  const GridDefaults = {
    column: 12,
    minRow: 0,
    maxRow: 0,
    itemClass: "grid-stack-item",
    placeholderClass: "grid-stack-placeholder",
    placeholderText: "",
    handle: ".grid-stack-item-content",
    handleClass: null,
    styleInHead: false,
    cellHeight: "auto",
    cellHeightThrottle: 100,
    margin: 10,
    auto: true,
    minWidth: 768,
    float: false,
    staticGrid: false,
    animate: true,
    alwaysShowResizeHandle: false,
    resizable: {
      autoHide: true,
      handles: "se"
    },
    draggable: {
      handle: ".grid-stack-item-content",
      scroll: false,
      appendTo: "body"
    },
    disableDrag: false,
    disableResize: false,
    rtl: "auto",
    removable: false,
    removableOptions: {
      accept: ".grid-stack-item"
    },
    marginUnit: "px",
    cellHeightUnit: "px",
    disableOneColumnMode: false,
    oneColumnModeDomSort: false
  };
  class GridStack {
    constructor(el, opts = {}) {
      this._gsEventHandler = {};
      this._extraDragRow = 0;
      this.el = el;
      opts = opts || {};
      if (opts.row) {
        opts.minRow = opts.maxRow = opts.row;
        delete opts.row;
      }
      let rowAttr = utils_12.Utils.toNumber(el.getAttribute("gs-row"));
      if (opts.column === "auto") {
        delete opts.column;
      }
      let defaults = Object.assign(Object.assign({}, utils_12.Utils.cloneDeep(GridDefaults)), { column: utils_12.Utils.toNumber(el.getAttribute("gs-column")) || 12, minRow: rowAttr ? rowAttr : utils_12.Utils.toNumber(el.getAttribute("gs-min-row")) || 0, maxRow: rowAttr ? rowAttr : utils_12.Utils.toNumber(el.getAttribute("gs-max-row")) || 0, staticGrid: utils_12.Utils.toBool(el.getAttribute("gs-static")) || false, _styleSheetClass: "grid-stack-instance-" + (Math.random() * 1e4).toFixed(0), alwaysShowResizeHandle: opts.alwaysShowResizeHandle || false, resizable: {
        autoHide: !(opts.alwaysShowResizeHandle || false),
        handles: "se"
      }, draggable: {
        handle: (opts.handleClass ? "." + opts.handleClass : opts.handle ? opts.handle : "") || ".grid-stack-item-content",
        scroll: false,
        appendTo: "body"
      }, removableOptions: {
        accept: "." + (opts.itemClass || "grid-stack-item")
      } });
      if (el.getAttribute("gs-animate")) {
        defaults.animate = utils_12.Utils.toBool(el.getAttribute("gs-animate"));
      }
      this.opts = utils_12.Utils.defaults(opts, defaults);
      opts = null;
      this.initMargin();
      if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.minWidth) {
        this._prevColumn = this.getColumn();
        this.opts.column = 1;
      }
      if (this.opts.rtl === "auto") {
        this.opts.rtl = el.style.direction === "rtl";
      }
      if (this.opts.rtl) {
        this.el.classList.add("grid-stack-rtl");
      }
      let parentGridItemEl = utils_12.Utils.closestByClass(this.el, GridDefaults.itemClass);
      if (parentGridItemEl && parentGridItemEl.gridstackNode) {
        this.opts._isNested = parentGridItemEl.gridstackNode;
        this.opts._isNested.subGrid = this;
        parentGridItemEl.classList.add("grid-stack-nested");
        this.el.classList.add("grid-stack-nested");
      }
      this._isAutoCellHeight = this.opts.cellHeight === "auto";
      if (this._isAutoCellHeight || this.opts.cellHeight === "initial") {
        this.cellHeight(void 0, false);
      } else {
        if (typeof this.opts.cellHeight == "number" && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== GridDefaults.cellHeightUnit) {
          this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;
          delete this.opts.cellHeightUnit;
        }
        this.cellHeight(this.opts.cellHeight, false);
      }
      this.el.classList.add(this.opts._styleSheetClass);
      this._setStaticClass();
      this.engine = new gridstack_engine_1.GridStackEngine({
        column: this.getColumn(),
        float: this.opts.float,
        maxRow: this.opts.maxRow,
        onChange: (cbNodes) => {
          let maxH = 0;
          this.engine.nodes.forEach((n) => {
            maxH = Math.max(maxH, n.y + n.h);
          });
          cbNodes.forEach((n) => {
            let el2 = n.el;
            if (!el2)
              return;
            if (n._removeDOM) {
              if (el2)
                el2.remove();
              delete n._removeDOM;
            } else {
              this._writePosAttr(el2, n);
            }
          });
          this._updateStyles(false, maxH);
        }
      });
      if (this.opts.auto) {
        this.batchUpdate();
        let elements = [];
        this.getGridItems().forEach((el2) => {
          let x = parseInt(el2.getAttribute("gs-x"));
          let y = parseInt(el2.getAttribute("gs-y"));
          elements.push({
            el: el2,
            i: (Number.isNaN(x) ? 1e3 : x) + (Number.isNaN(y) ? 1e3 : y) * this.getColumn()
          });
        });
        elements.sort((a, b) => a.i - b.i).forEach((e) => this._prepareElement(e.el));
        this.commit();
      }
      this.setAnimation(this.opts.animate);
      this._updateStyles();
      if (this.opts.column != 12) {
        this.el.classList.add("grid-stack-" + this.opts.column);
      }
      if (this.opts.dragIn)
        GridStack.setupDragIn(this.opts.dragIn, this.opts.dragInOptions);
      delete this.opts.dragIn;
      delete this.opts.dragInOptions;
      this._setupRemoveDrop();
      this._setupAcceptWidget();
      this._updateWindowResizeEvent();
    }
    static init(options = {}, elOrString = ".grid-stack") {
      let el = GridStack.getGridElement(elOrString);
      if (!el) {
        if (typeof elOrString === "string") {
          console.error('GridStack.initAll() no grid was found with selector "' + elOrString + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
        } else {
          console.error("GridStack.init() no grid element was passed.");
        }
        return null;
      }
      if (!el.gridstack) {
        el.gridstack = new GridStack(el, utils_12.Utils.cloneDeep(options));
      }
      return el.gridstack;
    }
    static initAll(options = {}, selector = ".grid-stack") {
      let grids = [];
      GridStack.getGridElements(selector).forEach((el) => {
        if (!el.gridstack) {
          el.gridstack = new GridStack(el, utils_12.Utils.cloneDeep(options));
          delete options.dragIn;
          delete options.dragInOptions;
        }
        grids.push(el.gridstack);
      });
      if (grids.length === 0) {
        console.error('GridStack.initAll() no grid was found with selector "' + selector + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
      }
      return grids;
    }
    static addGrid(parent, opt = {}) {
      if (!parent)
        return null;
      let el = parent;
      if (!parent.classList.contains("grid-stack")) {
        let doc = document.implementation.createHTMLDocument("");
        doc.body.innerHTML = `<div class="grid-stack ${opt.class || ""}"></div>`;
        el = doc.body.children[0];
        parent.appendChild(el);
      }
      let grid = GridStack.init(opt, el);
      if (grid.opts.children) {
        let children = grid.opts.children;
        delete grid.opts.children;
        grid.load(children);
      }
      return grid;
    }
    get placeholder() {
      if (!this._placeholder) {
        let placeholderChild = document.createElement("div");
        placeholderChild.className = "placeholder-content";
        if (this.opts.placeholderText) {
          placeholderChild.innerHTML = this.opts.placeholderText;
        }
        this._placeholder = document.createElement("div");
        this._placeholder.classList.add(this.opts.placeholderClass, GridDefaults.itemClass, this.opts.itemClass);
        this.placeholder.appendChild(placeholderChild);
      }
      return this._placeholder;
    }
    addWidget(els, options) {
      if (arguments.length > 2) {
        console.warn("gridstack.ts: `addWidget(el, x, y, width...)` is deprecated. Use `addWidget({x, y, w, content, ...})`. It will be removed soon");
        let a = arguments, i = 1, opt = {
          x: a[i++],
          y: a[i++],
          w: a[i++],
          h: a[i++],
          autoPosition: a[i++],
          minW: a[i++],
          maxW: a[i++],
          minH: a[i++],
          maxH: a[i++],
          id: a[i++]
        };
        return this.addWidget(els, opt);
      }
      function isGridStackWidget(w) {
        return w.x !== void 0 || w.y !== void 0 || w.w !== void 0 || w.h !== void 0 || w.content !== void 0 ? true : false;
      }
      let el;
      if (typeof els === "string") {
        let doc = document.implementation.createHTMLDocument("");
        doc.body.innerHTML = els;
        el = doc.body.children[0];
      } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {
        let content = els ? els.content || "" : "";
        options = els;
        let doc = document.implementation.createHTMLDocument("");
        doc.body.innerHTML = `<div class="grid-stack-item ${this.opts.itemClass || ""}"><div class="grid-stack-item-content">${content}</div></div>`;
        el = doc.body.children[0];
      } else {
        el = els;
      }
      let domAttr = this._readAttr(el);
      options = utils_12.Utils.cloneDeep(options) || {};
      utils_12.Utils.defaults(options, domAttr);
      let node = this.engine.prepareNode(options);
      this._writeAttr(el, options);
      if (this._insertNotAppend) {
        this.el.prepend(el);
      } else {
        this.el.appendChild(el);
      }
      this._prepareElement(el, true, options);
      this._updateContainerHeight();
      if (node.subGrid && !node.subGrid.el) {
        let autoColumn;
        let ops = node.subGrid;
        if (ops.column === "auto") {
          ops.column = node.w;
          ops.disableOneColumnMode = true;
          autoColumn = true;
        }
        let content = node.el.querySelector(".grid-stack-item-content");
        node.subGrid = GridStack.addGrid(content, node.subGrid);
        if (autoColumn) {
          node.subGrid._autoColumn = true;
        }
      }
      this._triggerAddEvent();
      this._triggerChangeEvent();
      return el;
    }
    save(saveContent = true, saveGridOpt = false) {
      let list = this.engine.save(saveContent);
      list.forEach((n) => {
        if (saveContent && n.el && !n.subGrid) {
          let sub = n.el.querySelector(".grid-stack-item-content");
          n.content = sub ? sub.innerHTML : void 0;
          if (!n.content)
            delete n.content;
        } else {
          if (!saveContent) {
            delete n.content;
          }
          if (n.subGrid) {
            n.subGrid = n.subGrid.save(saveContent, true);
          }
        }
        delete n.el;
      });
      if (saveGridOpt) {
        let o = utils_12.Utils.cloneDeep(this.opts);
        if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {
          o.margin = o.marginTop;
          delete o.marginTop;
          delete o.marginRight;
          delete o.marginBottom;
          delete o.marginLeft;
        }
        if (o.rtl === (this.el.style.direction === "rtl")) {
          o.rtl = "auto";
        }
        if (this._isAutoCellHeight) {
          o.cellHeight = "auto";
        }
        if (this._autoColumn) {
          o.column = "auto";
          delete o.disableOneColumnMode;
        }
        utils_12.Utils.removeInternalAndSame(o, GridDefaults);
        o.children = list;
        return o;
      }
      return list;
    }
    load(layout, addAndRemove = true) {
      let items = GridStack.Utils.sort([...layout], -1, this._prevColumn || this.getColumn());
      this._insertNotAppend = true;
      if (this._prevColumn && this._prevColumn !== this.opts.column && items.some((n) => n.x + n.w > this.opts.column)) {
        this._ignoreLayoutsNodeChange = true;
        this.engine.cacheLayout(items, this._prevColumn, true);
      }
      let removed = [];
      this.batchUpdate();
      if (addAndRemove) {
        let copyNodes = [...this.engine.nodes];
        copyNodes.forEach((n) => {
          let item = items.find((w) => n.id === w.id);
          if (!item) {
            if (typeof addAndRemove === "function") {
              addAndRemove(this, n, false);
            } else {
              removed.push(n);
              this.removeWidget(n.el, true, false);
            }
          }
        });
      }
      items.forEach((w) => {
        let item = w.id || w.id === 0 ? this.engine.nodes.find((n) => n.id === w.id) : void 0;
        if (item) {
          this.update(item.el, w);
          if (w.subGrid && w.subGrid.children) {
            let sub = item.el.querySelector(".grid-stack");
            if (sub && sub.gridstack) {
              sub.gridstack.load(w.subGrid.children);
              this._insertNotAppend = true;
            }
          }
        } else if (addAndRemove) {
          if (typeof addAndRemove === "function") {
            w = addAndRemove(this, w, true).gridstackNode;
          } else {
            w = this.addWidget(w).gridstackNode;
          }
        }
      });
      this.engine.removedNodes = removed;
      this.commit();
      delete this._ignoreLayoutsNodeChange;
      delete this._insertNotAppend;
      return this;
    }
    batchUpdate() {
      this.engine.batchUpdate();
      return this;
    }
    getCellHeight(forcePixel = false) {
      if (this.opts.cellHeight && this.opts.cellHeight !== "auto" && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === "px")) {
        return this.opts.cellHeight;
      }
      let el = this.el.querySelector("." + this.opts.itemClass);
      if (el) {
        let height = utils_12.Utils.toNumber(el.getAttribute("gs-h"));
        return Math.round(el.offsetHeight / height);
      }
      let rows = parseInt(this.el.getAttribute("gs-current-row"));
      return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;
    }
    cellHeight(val, update = true) {
      if (update && val !== void 0) {
        if (this._isAutoCellHeight !== (val === "auto")) {
          this._isAutoCellHeight = val === "auto";
          this._updateWindowResizeEvent();
        }
      }
      if (val === "initial" || val === "auto") {
        val = void 0;
      }
      if (val === void 0) {
        let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;
        val = this.cellWidth() + marginDiff;
      }
      let data = utils_12.Utils.parseHeight(val);
      if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {
        return this;
      }
      this.opts.cellHeightUnit = data.unit;
      this.opts.cellHeight = data.h;
      if (update) {
        this._updateStyles(true, this.getRow());
      }
      return this;
    }
    cellWidth() {
      return this._widthOrContainer() / this.getColumn();
    }
    _widthOrContainer() {
      return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;
    }
    commit() {
      this.engine.commit();
      this._triggerRemoveEvent();
      this._triggerAddEvent();
      this._triggerChangeEvent();
      return this;
    }
    compact() {
      this.engine.compact();
      this._triggerChangeEvent();
      return this;
    }
    column(column, layout = "moveScale") {
      if (column < 1 || this.opts.column === column)
        return this;
      let oldColumn = this.getColumn();
      if (column === 1) {
        this._prevColumn = oldColumn;
      } else {
        delete this._prevColumn;
      }
      this.el.classList.remove("grid-stack-" + oldColumn);
      this.el.classList.add("grid-stack-" + column);
      this.opts.column = this.engine.column = column;
      let domNodes;
      if (column === 1 && this.opts.oneColumnModeDomSort) {
        domNodes = [];
        this.getGridItems().forEach((el) => {
          if (el.gridstackNode) {
            domNodes.push(el.gridstackNode);
          }
        });
        if (!domNodes.length) {
          domNodes = void 0;
        }
      }
      this.engine.updateNodeWidths(oldColumn, column, domNodes, layout);
      if (this._isAutoCellHeight)
        this.cellHeight();
      this._ignoreLayoutsNodeChange = true;
      this._triggerChangeEvent();
      delete this._ignoreLayoutsNodeChange;
      return this;
    }
    getColumn() {
      return this.opts.column;
    }
    getGridItems() {
      return Array.from(this.el.children).filter((el) => el.matches("." + this.opts.itemClass) && !el.matches("." + this.opts.placeholderClass));
    }
    destroy(removeDOM = true) {
      if (!this.el)
        return;
      this._updateWindowResizeEvent(true);
      this.setStatic(true, false);
      this.setAnimation(false);
      if (!removeDOM) {
        this.removeAll(removeDOM);
        this.el.classList.remove(this.opts._styleSheetClass);
      } else {
        this.el.parentNode.removeChild(this.el);
      }
      this._removeStylesheet();
      this.el.removeAttribute("gs-current-row");
      delete this.opts._isNested;
      delete this.opts;
      delete this._placeholder;
      delete this.engine;
      delete this.el.gridstack;
      delete this.el;
      return this;
    }
    float(val) {
      this.engine.float = val;
      this._triggerChangeEvent();
      return this;
    }
    getFloat() {
      return this.engine.float;
    }
    getCellFromPixel(position, useDocRelative = false) {
      let box = this.el.getBoundingClientRect();
      let containerPos;
      if (useDocRelative) {
        containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };
      } else {
        containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft };
      }
      let relativeLeft = position.left - containerPos.left;
      let relativeTop = position.top - containerPos.top;
      let columnWidth = box.width / this.getColumn();
      let rowHeight = box.height / parseInt(this.el.getAttribute("gs-current-row"));
      return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };
    }
    getRow() {
      return Math.max(this.engine.getRow(), this.opts.minRow);
    }
    isAreaEmpty(x, y, w, h) {
      return this.engine.isAreaEmpty(x, y, w, h);
    }
    makeWidget(els) {
      let el = GridStack.getElement(els);
      this._prepareElement(el, true);
      this._updateContainerHeight();
      this._triggerAddEvent();
      this._triggerChangeEvent();
      return el;
    }
    on(name, callback) {
      if (name.indexOf(" ") !== -1) {
        let names = name.split(" ");
        names.forEach((name2) => this.on(name2, callback));
        return this;
      }
      if (name === "change" || name === "added" || name === "removed" || name === "enable" || name === "disable") {
        let noData = name === "enable" || name === "disable";
        if (noData) {
          this._gsEventHandler[name] = (event) => callback(event);
        } else {
          this._gsEventHandler[name] = (event) => callback(event, event.detail);
        }
        this.el.addEventListener(name, this._gsEventHandler[name]);
      } else if (name === "drag" || name === "dragstart" || name === "dragstop" || name === "resizestart" || name === "resize" || name === "resizestop" || name === "dropped") {
        this._gsEventHandler[name] = callback;
      } else {
        console.log("GridStack.on(" + name + ') event not supported, but you can still use $(".grid-stack").on(...) while jquery-ui is still used internally.');
      }
      return this;
    }
    off(name) {
      if (name.indexOf(" ") !== -1) {
        let names = name.split(" ");
        names.forEach((name2) => this.off(name2));
        return this;
      }
      if (name === "change" || name === "added" || name === "removed" || name === "enable" || name === "disable") {
        if (this._gsEventHandler[name]) {
          this.el.removeEventListener(name, this._gsEventHandler[name]);
        }
      }
      delete this._gsEventHandler[name];
      return this;
    }
    removeWidget(els, removeDOM = true, triggerEvent = true) {
      GridStack.getElements(els).forEach((el) => {
        if (el.parentElement !== this.el)
          return;
        let node = el.gridstackNode;
        if (!node) {
          node = this.engine.nodes.find((n) => el === n.el);
        }
        if (!node)
          return;
        delete el.gridstackNode;
        gridstack_ddi_1.GridStackDDI.get().remove(el);
        this.engine.removeNode(node, removeDOM, triggerEvent);
        if (removeDOM && el.parentElement) {
          el.remove();
        }
      });
      if (triggerEvent) {
        this._triggerRemoveEvent();
        this._triggerChangeEvent();
      }
      return this;
    }
    removeAll(removeDOM = true) {
      this.engine.nodes.forEach((n) => {
        delete n.el.gridstackNode;
        gridstack_ddi_1.GridStackDDI.get().remove(n.el);
      });
      this.engine.removeAll(removeDOM);
      this._triggerRemoveEvent();
      return this;
    }
    setAnimation(doAnimate) {
      if (doAnimate) {
        this.el.classList.add("grid-stack-animate");
      } else {
        this.el.classList.remove("grid-stack-animate");
      }
      return this;
    }
    setStatic(val, updateClass = true) {
      if (this.opts.staticGrid === val)
        return this;
      this.opts.staticGrid = val;
      this._setupRemoveDrop();
      this._setupAcceptWidget();
      this.engine.nodes.forEach((n) => this._prepareDragDropByNode(n));
      if (updateClass) {
        this._setStaticClass();
      }
      return this;
    }
    update(els, opt) {
      if (arguments.length > 2) {
        console.warn("gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon");
        let a = arguments, i = 1;
        opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++] };
        return this.update(els, opt);
      }
      GridStack.getElements(els).forEach((el) => {
        if (!el || !el.gridstackNode)
          return;
        let n = el.gridstackNode;
        let w = utils_12.Utils.cloneDeep(opt);
        delete w.autoPosition;
        let keys = ["x", "y", "w", "h"];
        let m;
        if (keys.some((k) => w[k] !== void 0 && w[k] !== n[k])) {
          m = {};
          keys.forEach((k) => {
            m[k] = w[k] !== void 0 ? w[k] : n[k];
            delete w[k];
          });
        }
        if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {
          m = {};
        }
        if (w.content) {
          let sub = el.querySelector(".grid-stack-item-content");
          if (sub && sub.innerHTML !== w.content) {
            sub.innerHTML = w.content;
          }
          delete w.content;
        }
        let changed = false;
        let ddChanged = false;
        for (const key in w) {
          if (key[0] !== "_" && n[key] !== w[key]) {
            n[key] = w[key];
            changed = true;
            ddChanged = ddChanged || !this.opts.staticGrid && (key === "noResize" || key === "noMove" || key === "locked");
          }
        }
        if (m) {
          this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);
          this._updateContainerHeight();
          this._triggerChangeEvent();
          this.engine.endUpdate();
        }
        if (changed) {
          this._writeAttr(el, n);
        }
        if (ddChanged) {
          this._prepareDragDropByNode(n);
        }
      });
      return this;
    }
    margin(value) {
      let isMultiValue = typeof value === "string" && value.split(" ").length > 1;
      if (!isMultiValue) {
        let data = utils_12.Utils.parseHeight(value);
        if (this.opts.marginUnit === data.unit && this.opts.margin === data.h)
          return;
      }
      this.opts.margin = value;
      this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = void 0;
      this.initMargin();
      this._updateStyles(true);
      return this;
    }
    getMargin() {
      return this.opts.margin;
    }
    willItFit(node) {
      if (arguments.length > 1) {
        console.warn("gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon");
        let a = arguments, i = 0, w = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };
        return this.willItFit(w);
      }
      return this.engine.willItFit(node);
    }
    _triggerChangeEvent() {
      if (this.engine.batchMode)
        return this;
      let elements = this.engine.getDirtyNodes(true);
      if (elements && elements.length) {
        if (!this._ignoreLayoutsNodeChange) {
          this.engine.layoutsNodesChange(elements);
        }
        this._triggerEvent("change", elements);
      }
      this.engine.saveInitial();
      return this;
    }
    _triggerAddEvent() {
      if (this.engine.batchMode)
        return this;
      if (this.engine.addedNodes && this.engine.addedNodes.length > 0) {
        if (!this._ignoreLayoutsNodeChange) {
          this.engine.layoutsNodesChange(this.engine.addedNodes);
        }
        this.engine.addedNodes.forEach((n) => {
          delete n._dirty;
        });
        this._triggerEvent("added", this.engine.addedNodes);
        this.engine.addedNodes = [];
      }
      return this;
    }
    _triggerRemoveEvent() {
      if (this.engine.batchMode)
        return this;
      if (this.engine.removedNodes && this.engine.removedNodes.length > 0) {
        this._triggerEvent("removed", this.engine.removedNodes);
        this.engine.removedNodes = [];
      }
      return this;
    }
    _triggerEvent(name, data) {
      let event = data ? new CustomEvent(name, { bubbles: false, detail: data }) : new Event(name);
      this.el.dispatchEvent(event);
      return this;
    }
    _removeStylesheet() {
      if (this._styles) {
        utils_12.Utils.removeStylesheet(this._styles._id);
        delete this._styles;
      }
      return this;
    }
    _updateStyles(forceUpdate = false, maxH) {
      if (forceUpdate) {
        this._removeStylesheet();
      }
      this._updateContainerHeight();
      if (this.opts.cellHeight === 0) {
        return this;
      }
      let cellHeight = this.opts.cellHeight;
      let cellHeightUnit = this.opts.cellHeightUnit;
      let prefix = `.${this.opts._styleSheetClass} > .${this.opts.itemClass}`;
      if (!this._styles) {
        let id = "gridstack-style-" + (Math.random() * 1e5).toFixed();
        let styleLocation = this.opts.styleInHead ? void 0 : this.el.parentNode;
        this._styles = utils_12.Utils.createStylesheet(id, styleLocation);
        if (!this._styles)
          return this;
        this._styles._id = id;
        this._styles._max = 0;
        utils_12.Utils.addCSSRule(this._styles, prefix, `min-height: ${cellHeight}${cellHeightUnit}`);
        let top = this.opts.marginTop + this.opts.marginUnit;
        let bottom = this.opts.marginBottom + this.opts.marginUnit;
        let right = this.opts.marginRight + this.opts.marginUnit;
        let left = this.opts.marginLeft + this.opts.marginUnit;
        let content = `${prefix} > .grid-stack-item-content`;
        let placeholder = `.${this.opts._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;
        utils_12.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
        utils_12.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);
        utils_12.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);
      }
      maxH = maxH || this._styles._max;
      if (maxH > this._styles._max) {
        let getHeight = (rows) => cellHeight * rows + cellHeightUnit;
        for (let i = this._styles._max + 1; i <= maxH; i++) {
          let h = getHeight(i);
          utils_12.Utils.addCSSRule(this._styles, `${prefix}[gs-y="${i - 1}"]`, `top: ${getHeight(i - 1)}`);
          utils_12.Utils.addCSSRule(this._styles, `${prefix}[gs-h="${i}"]`, `height: ${h}`);
          utils_12.Utils.addCSSRule(this._styles, `${prefix}[gs-min-h="${i}"]`, `min-height: ${h}`);
          utils_12.Utils.addCSSRule(this._styles, `${prefix}[gs-max-h="${i}"]`, `max-height: ${h}`);
        }
        this._styles._max = maxH;
      }
      return this;
    }
    _updateContainerHeight() {
      if (!this.engine || this.engine.batchMode)
        return this;
      let row = this.getRow() + this._extraDragRow;
      this.el.setAttribute("gs-current-row", String(row));
      if (row === 0) {
        this.el.style.removeProperty("height");
        return this;
      }
      let cellHeight = this.opts.cellHeight;
      let unit = this.opts.cellHeightUnit;
      if (!cellHeight)
        return this;
      this.el.style.height = row * cellHeight + unit;
      return this;
    }
    _prepareElement(el, triggerAddEvent = false, node) {
      if (!node) {
        el.classList.add(this.opts.itemClass);
        node = this._readAttr(el);
      }
      el.gridstackNode = node;
      node.el = el;
      node.grid = this;
      let copy = Object.assign({}, node);
      node = this.engine.addNode(node, triggerAddEvent);
      if (!utils_12.Utils.same(node, copy)) {
        this._writeAttr(el, node);
      }
      this._prepareDragDropByNode(node);
      return this;
    }
    _writePosAttr(el, n) {
      if (n.x !== void 0 && n.x !== null) {
        el.setAttribute("gs-x", String(n.x));
      }
      if (n.y !== void 0 && n.y !== null) {
        el.setAttribute("gs-y", String(n.y));
      }
      if (n.w) {
        el.setAttribute("gs-w", String(n.w));
      }
      if (n.h) {
        el.setAttribute("gs-h", String(n.h));
      }
      return this;
    }
    _writeAttr(el, node) {
      if (!node)
        return this;
      this._writePosAttr(el, node);
      let attrs = {
        autoPosition: "gs-auto-position",
        minW: "gs-min-w",
        minH: "gs-min-h",
        maxW: "gs-max-w",
        maxH: "gs-max-h",
        noResize: "gs-no-resize",
        noMove: "gs-no-move",
        locked: "gs-locked",
        id: "gs-id",
        resizeHandles: "gs-resize-handles"
      };
      for (const key in attrs) {
        if (node[key]) {
          el.setAttribute(attrs[key], String(node[key]));
        } else {
          el.removeAttribute(attrs[key]);
        }
      }
      return this;
    }
    _readAttr(el) {
      let node = {};
      node.x = utils_12.Utils.toNumber(el.getAttribute("gs-x"));
      node.y = utils_12.Utils.toNumber(el.getAttribute("gs-y"));
      node.w = utils_12.Utils.toNumber(el.getAttribute("gs-w"));
      node.h = utils_12.Utils.toNumber(el.getAttribute("gs-h"));
      node.maxW = utils_12.Utils.toNumber(el.getAttribute("gs-max-w"));
      node.minW = utils_12.Utils.toNumber(el.getAttribute("gs-min-w"));
      node.maxH = utils_12.Utils.toNumber(el.getAttribute("gs-max-h"));
      node.minH = utils_12.Utils.toNumber(el.getAttribute("gs-min-h"));
      node.autoPosition = utils_12.Utils.toBool(el.getAttribute("gs-auto-position"));
      node.noResize = utils_12.Utils.toBool(el.getAttribute("gs-no-resize"));
      node.noMove = utils_12.Utils.toBool(el.getAttribute("gs-no-move"));
      node.locked = utils_12.Utils.toBool(el.getAttribute("gs-locked"));
      node.resizeHandles = el.getAttribute("gs-resize-handles");
      node.id = el.getAttribute("gs-id");
      for (const key in node) {
        if (!node.hasOwnProperty(key))
          return;
        if (!node[key] && node[key] !== 0) {
          delete node[key];
        }
      }
      return node;
    }
    _setStaticClass() {
      let classes = ["grid-stack-static"];
      if (this.opts.staticGrid) {
        this.el.classList.add(...classes);
        this.el.setAttribute("gs-static", "true");
      } else {
        this.el.classList.remove(...classes);
        this.el.removeAttribute("gs-static");
      }
      return this;
    }
    onParentResize() {
      if (!this.el || !this.el.clientWidth)
        return;
      let changedColumn = false;
      if (this._autoColumn && this.opts._isNested) {
        if (this.opts.column !== this.opts._isNested.w) {
          changedColumn = true;
          this.column(this.opts._isNested.w, "none");
        }
      } else {
        let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.minWidth;
        if (this.opts.column === 1 !== oneColumn) {
          changedColumn = true;
          if (this.opts.animate) {
            this.setAnimation(false);
          }
          this.column(oneColumn ? 1 : this._prevColumn);
          if (this.opts.animate) {
            this.setAnimation(true);
          }
        }
      }
      if (this._isAutoCellHeight) {
        if (!changedColumn && this.opts.cellHeightThrottle) {
          if (!this._cellHeightThrottle) {
            this._cellHeightThrottle = utils_12.Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle);
          }
          this._cellHeightThrottle();
        } else {
          this.cellHeight();
        }
      }
      this.engine.nodes.forEach((n) => {
        if (n.subGrid) {
          n.subGrid.onParentResize();
        }
      });
      return this;
    }
    _updateWindowResizeEvent(forceRemove = false) {
      const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.opts._isNested;
      if (!forceRemove && workTodo && !this._windowResizeBind) {
        this._windowResizeBind = this.onParentResize.bind(this);
        window.addEventListener("resize", this._windowResizeBind);
      } else if ((forceRemove || !workTodo) && this._windowResizeBind) {
        window.removeEventListener("resize", this._windowResizeBind);
        delete this._windowResizeBind;
      }
      return this;
    }
    static getElement(els = ".grid-stack-item") {
      return utils_12.Utils.getElement(els);
    }
    static getElements(els = ".grid-stack-item") {
      return utils_12.Utils.getElements(els);
    }
    static getGridElement(els) {
      return GridStack.getElement(els);
    }
    static getGridElements(els) {
      return utils_12.Utils.getElements(els);
    }
    initMargin() {
      let data;
      let margin = 0;
      let margins = [];
      if (typeof this.opts.margin === "string") {
        margins = this.opts.margin.split(" ");
      }
      if (margins.length === 2) {
        this.opts.marginTop = this.opts.marginBottom = margins[0];
        this.opts.marginLeft = this.opts.marginRight = margins[1];
      } else if (margins.length === 4) {
        this.opts.marginTop = margins[0];
        this.opts.marginRight = margins[1];
        this.opts.marginBottom = margins[2];
        this.opts.marginLeft = margins[3];
      } else {
        data = utils_12.Utils.parseHeight(this.opts.margin);
        this.opts.marginUnit = data.unit;
        margin = this.opts.margin = data.h;
      }
      if (this.opts.marginTop === void 0) {
        this.opts.marginTop = margin;
      } else {
        data = utils_12.Utils.parseHeight(this.opts.marginTop);
        this.opts.marginTop = data.h;
        delete this.opts.margin;
      }
      if (this.opts.marginBottom === void 0) {
        this.opts.marginBottom = margin;
      } else {
        data = utils_12.Utils.parseHeight(this.opts.marginBottom);
        this.opts.marginBottom = data.h;
        delete this.opts.margin;
      }
      if (this.opts.marginRight === void 0) {
        this.opts.marginRight = margin;
      } else {
        data = utils_12.Utils.parseHeight(this.opts.marginRight);
        this.opts.marginRight = data.h;
        delete this.opts.margin;
      }
      if (this.opts.marginLeft === void 0) {
        this.opts.marginLeft = margin;
      } else {
        data = utils_12.Utils.parseHeight(this.opts.marginLeft);
        this.opts.marginLeft = data.h;
        delete this.opts.margin;
      }
      this.opts.marginUnit = data.unit;
      if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {
        this.opts.margin = this.opts.marginTop;
      }
      return this;
    }
    static setupDragIn(dragIn, dragInOptions) {
    }
    movable(els, val) {
      return this;
    }
    resizable(els, val) {
      return this;
    }
    disable() {
      return this;
    }
    enable() {
      return this;
    }
    enableMove(doEnable) {
      return this;
    }
    enableResize(doEnable) {
      return this;
    }
    _setupAcceptWidget() {
      return this;
    }
    _setupRemoveDrop() {
      return this;
    }
    _prepareDragDropByNode(node) {
      return this;
    }
    _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {
      return;
    }
    _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {
      return;
    }
    _leave(el, helper) {
      return;
    }
  }
  exports.GridStack = GridStack;
  GridStack.Utils = utils_12.Utils;
  GridStack.Engine = gridstack_engine_1.GridStackEngine;
})(gridstack);
const _sfc_main$7 = defineComponent({
  name: "Checkbox",
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    label: {
      type: String,
      default: ""
    },
    toggleSwitch: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props, context) {
    const inputRef = ref(null);
    const inputValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        if (props.readonly)
          ;
        context.emit("update:modelValue", newValue);
        claimFocus();
      }
    });
    function claimFocus() {
      if (inputRef.value !== null) {
        inputRef.value.focus();
      }
    }
    function changeEvent(event) {
      if (props.readonly) {
        return;
      }
      const checked = event.target.checked;
      context.emit("change", checked);
    }
    function setValue() {
      if (props.readonly) {
        return;
      }
      inputValue.value = !inputValue.value;
    }
    return {
      inputValue,
      inputRef,
      setValue,
      changeEvent
    };
  }
});
const _hoisted_1$7 = ["readonly"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["checkbox-container", { readonly: _ctx.readonly }])
  }, [
    withDirectives(createBaseVNode("input", {
      class: normalizeClass(_ctx.toggleSwitch ? "passage-toggle-switch" : "passage-checkbox"),
      type: "checkbox",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
      ref: "inputRef",
      onChange: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.changeEvent && _ctx.changeEvent(...args), ["prevent"])),
      readonly: _ctx.readonly
    }, null, 42, _hoisted_1$7), [
      [vModelCheckbox, _ctx.inputValue]
    ]),
    createBaseVNode("div", {
      class: normalizeClass(["checkbox-label", { "toggle-switch-label": _ctx.toggleSwitch }]),
      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.setValue && _ctx.setValue(...args), ["prevent"]))
    }, toDisplayString(_ctx.label), 3)
  ], 2);
}
var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = defineComponent({
  name: "Validated String",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const { t } = useLocale();
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        context.emit("update:modelValue", newValue);
      }
    });
    const errorMessage = ref("");
    function validate() {
      var _a, _b;
      errorMessage.value = "";
      if (props.required && props.modelValue === void 0) {
        errorMessage.value = t("required");
        return false;
      }
      const validLength = ((_b = (_a = props.modelValue) == null ? void 0 : _a.length) != null ? _b : 0) < 64;
      if (!validLength) {
        errorMessage.value = t("64-letters-max");
      }
      return validLength;
    }
    return {
      reactiveValue,
      validate,
      errorMessage
    };
  }
});
const _hoisted_1$6 = { class: "validated-field" };
const _hoisted_2$6 = { class: "label" };
const _hoisted_3$5 = {
  key: 0,
  class: "input",
  part: "input",
  style: { "width": "100%" },
  value: "N/A",
  readonly: ""
};
const _hoisted_4$4 = ["placeholder", "readonly"];
const _hoisted_5$4 = { class: "error-message" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$6, toDisplayString(_ctx.label), 1),
    _ctx.readonly && !_ctx.modelValue ? (openBlock(), createElementBlock("input", _hoisted_3$5)) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      class: normalizeClass(["input", { "is-danger": _ctx.errorMessage }]),
      part: "input",
      style: { "width": "100%" },
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => _ctx.errorMessage = ""),
      readonly: _ctx.readonly
    }, null, 42, _hoisted_4$4)), [
      [vModelText, _ctx.reactiveValue]
    ]),
    createBaseVNode("div", _hoisted_5$4, toDisplayString(_ctx.errorMessage), 1)
  ]);
}
var ValidatedString = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _sfc_main$5 = defineComponent({
  name: "Validated String",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const { t } = useLocale();
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        context.emit("update:modelValue", newValue);
      }
    });
    const errorMessage = ref("");
    function validate() {
      var _a;
      errorMessage.value = "";
      if (props.required && props.modelValue === void 0) {
        errorMessage.value = t("required");
        return false;
      }
      const validDate = !props.modelValue || dayjs((_a = props.modelValue) != null ? _a : "", "YYYY-DD-MM").isValid();
      if (!validDate) {
        errorMessage.value = t("invalid-date");
      }
      return validDate;
    }
    return {
      reactiveValue,
      validate,
      errorMessage
    };
  }
});
const _hoisted_1$5 = { class: "validated-field" };
const _hoisted_2$5 = { class: "label" };
const _hoisted_3$4 = {
  key: 0,
  class: "input",
  part: "input",
  style: { "width": "100%" },
  value: "N/A",
  readonly: ""
};
const _hoisted_4$3 = ["placeholder", "readonly"];
const _hoisted_5$3 = { class: "error-message" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createBaseVNode("div", _hoisted_2$5, toDisplayString(_ctx.label), 1),
    _ctx.readonly && !_ctx.modelValue ? (openBlock(), createElementBlock("input", _hoisted_3$4)) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      class: normalizeClass(["input", { "is-danger": _ctx.errorMessage }]),
      part: "input",
      style: { "width": "100%" },
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => _ctx.errorMessage = ""),
      readonly: _ctx.readonly
    }, null, 42, _hoisted_4$3)), [
      [vModelText, _ctx.reactiveValue]
    ]),
    createBaseVNode("div", _hoisted_5$3, toDisplayString(_ctx.errorMessage), 1)
  ]);
}
var ValidatedDate = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const _sfc_main$4 = defineComponent({
  name: "Validated String",
  components: {
    Checkbox
  },
  props: {
    modelValue: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        context.emit("update:modelValue", newValue);
      }
    });
    function validate() {
      return true;
    }
    return {
      reactiveValue,
      validate
    };
  }
});
const _hoisted_1$4 = { class: "validated-field" };
const _hoisted_2$4 = { class: "label" };
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode("div", { class: "error-message" }, null, -1);
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_checkbox = resolveComponent("checkbox");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createBaseVNode("div", _hoisted_2$4, toDisplayString(_ctx.label), 1),
    createVNode(_component_checkbox, {
      modelValue: _ctx.reactiveValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      readonly: _ctx.readonly
    }, null, 8, ["modelValue", "readonly"]),
    _hoisted_3$3
  ]);
}
var ValidatedBoolean = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
function isEmail(email) {
  const emailRegEx = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return emailRegEx.test(email);
}
const _sfc_main$3 = defineComponent({
  name: "Validated String",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const { t } = useLocale();
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        context.emit("update:modelValue", newValue);
      }
    });
    const errorMessage = ref("");
    function validate() {
      var _a, _b, _c;
      errorMessage.value = "";
      if (props.required && props.modelValue === void 0) {
        errorMessage.value = t("required");
        return false;
      }
      const validLength = ((_b = (_a = props.modelValue) == null ? void 0 : _a.length) != null ? _b : 0) < 64;
      if (!validLength) {
        errorMessage.value = t("64-letters-max");
        return false;
      }
      const validEmail = !props.modelValue || isEmail((_c = props.modelValue) != null ? _c : "");
      if (!validEmail) {
        errorMessage.value = t("invalid-email");
      }
      return validEmail;
    }
    return {
      reactiveValue,
      validate,
      errorMessage
    };
  }
});
const _hoisted_1$3 = { class: "validated-field" };
const _hoisted_2$3 = { class: "label" };
const _hoisted_3$2 = {
  key: 0,
  class: "input",
  part: "input",
  style: { "width": "100%" },
  value: "N/A",
  readonly: ""
};
const _hoisted_4$2 = ["placeholder", "readonly"];
const _hoisted_5$2 = { class: "error-message" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2$3, toDisplayString(_ctx.label), 1),
    _ctx.readonly && !_ctx.modelValue ? (openBlock(), createElementBlock("input", _hoisted_3$2)) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      class: normalizeClass(["input", { "is-danger": _ctx.errorMessage }]),
      part: "input",
      style: { "width": "100%" },
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => _ctx.errorMessage = ""),
      readonly: _ctx.readonly,
      autocomplete: "email",
      inputmode: "email"
    }, null, 42, _hoisted_4$2)), [
      [vModelText, _ctx.reactiveValue]
    ]),
    createBaseVNode("div", _hoisted_5$2, toDisplayString(_ctx.errorMessage), 1)
  ]);
}
var ValidatedEmail = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = defineComponent({
  name: "Validated Integer",
  props: {
    modelValue: {
      type: Number
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const { t } = useLocale();
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        if (typeof newValue !== "number") {
          context.emit("update:modelValue", 0);
          return;
        }
        context.emit("update:modelValue", newValue);
      }
    });
    const errorMessage = ref("");
    function validate() {
      errorMessage.value = "";
      if (props.required && props.modelValue === void 0) {
        errorMessage.value = t("required");
        return false;
      }
      const validInt = !props.modelValue || Number.isInteger(props.modelValue);
      if (!validInt) {
        errorMessage.value = t("no-decimals");
      }
      return validInt;
    }
    function isInteger(event) {
      if (!/\d/.test(event.key) && event.key !== "-") {
        return event.preventDefault();
      }
    }
    return {
      reactiveValue,
      validate,
      errorMessage,
      isInteger
    };
  }
});
const _hoisted_1$2 = { class: "validated-field" };
const _hoisted_2$2 = { class: "label" };
const _hoisted_3$1 = {
  key: 0,
  class: "input",
  part: "input",
  style: { "width": "100%" },
  value: "N/A",
  readonly: ""
};
const _hoisted_4$1 = ["placeholder", "readonly"];
const _hoisted_5$1 = { class: "error-message" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createBaseVNode("div", _hoisted_2$2, toDisplayString(_ctx.label), 1),
    _ctx.readonly && !_ctx.modelValue ? (openBlock(), createElementBlock("input", _hoisted_3$1)) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      class: normalizeClass(["input", { "is-danger": _ctx.errorMessage }]),
      part: "input",
      style: { "width": "100%" },
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => _ctx.errorMessage = ""),
      readonly: _ctx.readonly,
      type: "number",
      inputmode: "decimal",
      autocomplete: "decimal",
      step: "1",
      pattern: "^[-/d]/d*$",
      onKeypress: _cache[2] || (_cache[2] = ($event) => _ctx.isInteger($event))
    }, null, 42, _hoisted_4$1)), [
      [
        vModelText,
        _ctx.reactiveValue,
        void 0,
        { number: true }
      ]
    ]),
    createBaseVNode("div", _hoisted_5$1, toDisplayString(_ctx.errorMessage), 1)
  ]);
}
var ValidatedInteger = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = defineComponent({
  name: "Validated String",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String
    },
    label: {
      type: String
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    const { t } = useLocale();
    const reactiveValue = computed({
      get() {
        return props.modelValue;
      },
      set(newValue) {
        context.emit("update:modelValue", newValue);
      }
    });
    const errorMessage = ref("");
    function validate() {
      var _a;
      errorMessage.value = "";
      if (props.required && props.modelValue === void 0) {
        errorMessage.value = t("required");
        return false;
      }
      const isValidPhone = !props.modelValue || ((_a = phoneInput == null ? void 0 : phoneInput.isValidNumber()) != null ? _a : false);
      if (!isValidPhone) {
        errorMessage.value = t("invalid-phone");
      } else {
        const number = phoneInput == null ? void 0 : phoneInput.getNumber();
        if (number) {
          context.emit("update:modelValue", phoneInput == null ? void 0 : phoneInput.getNumber());
        }
      }
      return isValidPhone;
    }
    const phoneInputBox = ref();
    const controlContainer = ref();
    const { defaultCountryCode } = useDefaultCountryCode();
    let phoneInput;
    function showCountryCode() {
      var _a;
      phoneInput = intlTelInput(phoneInputBox.value, {
        initialCountry: (_a = phoneInput == null ? void 0 : phoneInput.getSelectedCountryData().iso2) != null ? _a : defaultCountryCode.value,
        utilsScript: "https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/utils.js",
        dropdownContainer: controlContainer.value,
        autoPlaceholder: "aggressive"
      });
    }
    function hideCountryCode() {
      if (phoneInput === void 0) {
        return;
      }
      phoneInput.destroy();
      phoneInput = void 0;
    }
    onMounted(() => {
      if (!props.readonly) {
        showCountryCode();
      }
    });
    watch(
      () => props.readonly,
      () => {
        if (!props.readonly) {
          showCountryCode();
        } else {
          hideCountryCode();
        }
      }
    );
    return {
      reactiveValue,
      validate,
      errorMessage,
      phoneInputBox,
      controlContainer
    };
  }
});
const _hoisted_1$1 = { class: "validated-field" };
const _hoisted_2$1 = { class: "label" };
const _hoisted_3 = {
  class: "input",
  part: "input",
  style: { "width": "100%" },
  value: "N/A",
  readonly: ""
};
const _hoisted_4 = ["placeholder", "readonly"];
const _hoisted_5 = {
  ref: "controlContainer",
  style: { "width": "100%" }
};
const _hoisted_6 = { class: "error-message" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createBaseVNode("div", _hoisted_2$1, toDisplayString(_ctx.label), 1),
    withDirectives(createBaseVNode("input", _hoisted_3, null, 512), [
      [vShow, _ctx.readonly && !_ctx.modelValue]
    ]),
    withDirectives(createBaseVNode("input", {
      class: normalizeClass(["input", { "is-danger": _ctx.errorMessage }]),
      part: "input",
      style: { "width": "100%" },
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.reactiveValue = $event),
      onInput: _cache[1] || (_cache[1] = ($event) => _ctx.errorMessage = ""),
      readonly: _ctx.readonly,
      autocomplete: "tel",
      inputmode: "tel",
      ref: "phoneInputBox"
    }, null, 42, _hoisted_4), [
      [vShow, !_ctx.readonly || _ctx.modelValue],
      [vModelText, _ctx.reactiveValue]
    ]),
    withDirectives(createBaseVNode("div", _hoisted_5, null, 512), [
      [vShow, !_ctx.readonly || _ctx.modelValue]
    ]),
    createBaseVNode("div", _hoisted_6, toDisplayString(_ctx.errorMessage), 1)
  ]);
}
var ValidatedPhone = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var LayoutType = /* @__PURE__ */ ((LayoutType2) => {
  LayoutType2["Registration"] = "registration";
  LayoutType2["Profile"] = "profile";
  return LayoutType2;
})(LayoutType || {});
const _sfc_main = defineComponent({
  name: "User Metadata",
  components: {
    Checkbox,
    ValidatedString,
    ValidatedDate,
    ValidatedBoolean,
    ValidatedEmail,
    ValidatedInteger,
    ValidatedPhone
  },
  props: {
    appInfo: {
      type: Object,
      required: true
    },
    layoutType: {
      type: String,
      required: true
    },
    userMetadata: {
      type: Object,
      required: true
    },
    isEditing: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { t } = useLocale();
    const layout = computed(() => {
      return props.layoutType === "registration" ? props.appInfo.layouts.registration : props.appInfo.layouts.profile;
    });
    const schema = computed(() => {
      return props.appInfo.user_metadata_schema;
    });
    const items = computed(() => {
      return layout.value.map((layout2) => {
        const foundSchema = schema.value.find((schema2) => schema2.id === layout2.id);
        return __spreadProps(__spreadValues(__spreadValues({}, layout2), foundSchema), {
          placeholder: getPlaceholder(foundSchema),
          component: getComponent(foundSchema)
        });
      });
    });
    function getPlaceholder(schema2) {
      if (schema2 === void 0) {
        return "";
      }
      switch (schema2.type) {
        case ce.STRING:
          return t("enter-schema-friendly_name", [schema2.friendly_name.toLowerCase()]);
        case ce.BOOLEAN:
          return "";
        case ce.INTEGER:
          return "0";
        case ce.DATE:
          return "MM/DD/YYYY";
        case ce.PHONE:
          return "(555) 555-5555";
        case ce.EMAIL:
          return "example@email.com";
      }
    }
    function getComponent(schema2) {
      if (schema2 === void 0) {
        return "ValidatedString";
      }
      switch (schema2.type) {
        case ce.STRING:
          return "ValidatedString";
        case ce.BOOLEAN:
          return "ValidatedBoolean";
        case ce.INTEGER:
          return "ValidatedInteger";
        case ce.DATE:
          return "ValidatedDate";
        case ce.PHONE:
          return "ValidatedPhone";
        case ce.EMAIL:
          return "ValidatedEmail";
      }
    }
    const resizeObserver = new ResizeObserver(() => {
      grid.onParentResize();
    });
    let grid;
    const gridContainer = ref();
    onMounted(() => {
      if (!gridContainer.value) {
        return;
      }
      grid = gridstack.GridStack.init(
        {
          acceptWidgets: true,
          minRow: 1,
          cellHeight: "75px",
          minWidth: 400,
          column: 6,
          margin: "0px 10px",
          resizable: {
            handles: "e,w"
          },
          staticGrid: true
        },
        gridContainer.value
      );
      resizeObserver.observe(gridContainer.value);
    });
    const inputComponents = [];
    function setRef(component) {
      if (component) {
        inputComponents.push(component);
      }
    }
    function validate() {
      let allValid = true;
      inputComponents.forEach((component) => {
        const isValid = component.validate();
        if (!isValid) {
          allValid = false;
        }
      });
      return allValid;
    }
    return {
      layout,
      schema,
      items,
      gridContainer,
      setRef,
      validate,
      LayoutType
    };
  }
});
const _hoisted_1 = ["id", "gs-id", "gs-x", "gs-y", "gs-w", "gs-h"];
const _hoisted_2 = { class: "grid-stack-item-content" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["grid-stack", { profile: _ctx.layoutType === _ctx.LayoutType.Profile, register: _ctx.layoutType === _ctx.LayoutType.Registration }]),
    ref: "gridContainer"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item) => {
      return openBlock(), createElementBlock("div", {
        id: item.id,
        class: "grid-stack-item",
        key: item.id,
        "gs-id": item.id,
        "gs-x": item.x,
        "gs-y": item.y,
        "gs-w": item.w,
        "gs-h": item.h
      }, [
        createBaseVNode("div", _hoisted_2, [
          (openBlock(), createBlock(resolveDynamicComponent(item.component), {
            label: item.friendly_name,
            placeholder: item.placeholder,
            required: _ctx.layoutType === _ctx.LayoutType.Registration,
            modelValue: _ctx.userMetadata[item.field_name],
            "onUpdate:modelValue": ($event) => _ctx.userMetadata[item.field_name] = $event,
            ref_for: true,
            ref: _ctx.setRef,
            readonly: !_ctx.isEditing
          }, null, 8, ["label", "placeholder", "required", "modelValue", "onUpdate:modelValue", "readonly"]))
        ])
      ], 8, _hoisted_1);
    }), 128))
  ], 2);
}
var UserMetadata = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
function transformMetadata(metadata, schema, defaultBooleans = false) {
  const transformedMetadata = __spreadValues({}, metadata);
  schema.forEach((schema2) => {
    const metadataValue = transformedMetadata[schema2.field_name];
    if (schema2.type === ce.DATE && metadataValue) {
      transformedMetadata[schema2.field_name] = dayjs(metadataValue).format("YYYY-MM-DD");
    }
    if (defaultBooleans && schema2.type === ce.BOOLEAN && metadataValue === void 0) {
      transformedMetadata[schema2.field_name] = false;
    }
  });
  return transformedMetadata;
}
function useUpdateUser(appID) {
  const { t } = useLocale();
  const passage = new Y(appID);
  const passageUser = passage.getCurrentUser();
  const updateInfoMessage = ref("");
  const updateEmailError = ref("");
  const updatePhoneError = ref("");
  const updateMetadataError = ref("");
  const updatePending = ref(false);
  const identifierExists = (identifier) => __async(this, null, function* () {
    updatePending.value = true;
    const existingUser = yield passage.identifierExists(identifier);
    updatePending.value = false;
    if (existingUser) {
      return false;
    }
    return true;
  });
  const changeEmailRequest = (newEmail) => __async(this, null, function* () {
    updatePending.value = true;
    try {
      yield passageUser.changeEmail(newEmail);
      if (newEmail) {
        updateInfoMessage.value = updateInfoMessage.value = t("weve-sent-confirmation-email");
      }
    } catch (e) {
      updateEmailError.value = newEmail === "" ? t("your-account-must-have-either-an-email-or-a-phone") : t("failed-to-update-email");
    } finally {
      updatePending.value = false;
    }
  });
  const changePhoneRequest = (newPhone) => __async(this, null, function* () {
    updatePending.value = true;
    try {
      yield passageUser.changePhone(newPhone);
      if (newPhone) {
        updateInfoMessage.value = t("weve-sent-confirmation-text");
      }
    } catch (e) {
      updatePhoneError.value = newPhone === "" ? t("your-account-must-have-either-an-email-or-a-phone") : t("failed-to-update-phone");
    } finally {
      updatePending.value = false;
    }
  });
  const updateMetadata = (newMetadata, schema) => __async(this, null, function* () {
    updatePending.value = true;
    try {
      const transformedMetadata = transformMetadata(newMetadata, schema);
      yield passageUser.updateMetadata(transformedMetadata);
      return true;
    } catch (e) {
      updateMetadataError.value = t("failed-to-update-metadata");
      return false;
    } finally {
      updatePending.value = false;
    }
  });
  return {
    changeEmailRequest,
    updateEmailError,
    changePhoneRequest,
    updatePhoneError,
    updatePending,
    updateInfoMessage,
    identifierExists,
    updateMetadata,
    updateMetadataError
  };
}
export { LayoutType as L, UserMetadata as U, isEmail as a, intlTelInput as i, transformMetadata as t, useUpdateUser as u };
//# 
